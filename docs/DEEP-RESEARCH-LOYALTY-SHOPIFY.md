# Deep Research: Loyalty Redemption and Theme Extensions for Shopify

This report synthesizes research on two themes: (1) loyalty redemption flows for Shopify and headless storefronts, and (2) theme app extension patterns for loyalty widgets. The goal is to inform the MNKY Rewards implementation—custom loyalty in mood-mnky-command with Shopify storefront exposure via app proxy and theme extensions.

---

## Knowledge Development

Initial investigation focused on how third-party loyalty apps (e.g. Gameball) integrate with Shopify and how headless or custom backends can implement redemption and display balance on the storefront. The first finding was that Shopify’s own APIs split cleanly into three concerns: customer identity and data (Customer Account API), discount creation and management (Admin API, moving to GraphQL), and storefront presentation (theme app extensions and app proxy). None of these prescribe a single “loyalty” flow; they provide primitives that a custom system like MNKY Rewards can compose.

The Customer Account API emerged as the central mechanism for headless or hybrid storefronts where the shopper is authenticated. It is a GraphQL API intended for customer-authenticated experiences and exposes customer-scoped data including orders, payments, fulfillment, refunds, and—critically for loyalty—discount-related data. Documentation indicates that the API supports viewing cart discount codes, automatic discounts, and custom discount allocations with amounts, which aligns with showing “your applied rewards” or “available coupons” in a headless UI. Authentication uses OAuth 2.0 with PKCE for public clients, and discovery endpoints allow the app to adapt to any shop’s configuration. For MNKY VERSE, where customers may log in via Customer Account API (e.g. on Verse or after redirect from the native store), this API is the natural place to integrate “my rewards” and “my discount codes” once we issue codes via the Admin API. The evolution of understanding here was that redemption is not only “create a code and show it” but also “create a code, associate it with the customer, and optionally surface it in the Customer Account API context” so that headless checkouts or account pages can display and apply it consistently.

A second strand of research addressed how the native Shopify storefront (Liquid themes) can show loyalty without the customer being in our app. Theme app extensions consist of app blocks (inline content in sections) and app embed blocks (overlays, floating elements, or invisible code). Shopify’s documentation and third-party examples (e.g. LoyaltyLion) show that loyalty experiences are often delivered via app embeds: a single toggle in the theme editor enables the app’s global embed (e.g. a floating launcher), with no manual theme code edits. App blocks, by contrast, are added per section and suit content like “Earn X points on this product” or a rewards summary in a dedicated section. Both patterns are supported in Online Store 2.0 themes; the extension bundle includes Liquid, CSS, and JavaScript assets. This clarified that the MNKY Rewards launcher should be implemented as an app embed block (or equivalent) so merchants can enable it once and have it appear store-wide, while “potential points” and “balance” can be section-level app blocks for placement on product or account pages.

The third major finding concerned app proxy security and customer identity. Shopify’s official documentation on authenticating app proxies states that when a request is forwarded through the proxy, Shopify adds parameters including `logged_in_customer_id`, `shop`, `path_prefix`, `timestamp`, and `signature`. The `logged_in_customer_id` is populated when a customer is logged in on the storefront and is empty otherwise. The signature is an HMAC-SHA256 of the other parameters (sorted, concatenated) using the app’s shared secret, so the backend can verify that the request originated from Shopify and was not tampered with. Importantly, the documentation cautions that the app must still ensure that the `logged_in_customer_id` matches the data being returned—i.e. we must only return balance or rewards for that customer. Cookies are stripped on proxy requests, so customer context depends entirely on these query parameters. For MNKY Rewards, this means the balance endpoint (`GET /apps/mnky/api/balance`) can rely on Shopify-provided `logged_in_customer_id` after signature verification, mapping that ID to `profiles.shopify_customer_id` and then to `xp_state`. No custom signed token is required for storefront-originated balance requests; the proxy’s built-in parameters suffice. This simplifies the design in SHOPIFY-LOYALTY-EXTENSION.md, where we had considered custom signing or cookies.

Discount creation for redemption was the fourth area. The Shopify Admin API supports creating discount codes programmatically. The GraphQL mutation `discountCodeBasicCreate` creates amount-off or percentage-off codes that customers enter at checkout; it requires the `write_discounts` scope. The API allows specifying discount value, dates, customer eligibility, usage limits (e.g. once per customer), and applicable items or collections. There is also support for bulk discount code creation under a price rule, which fits loyalty use cases where many single-use codes are generated (e.g. one per redemption). Legacy REST PriceRule and DiscountCode resources are being superseded by GraphQL discount types, so new implementations should use the GraphQL API. For MNKY Rewards, the flow is: when a user redeems “500 XP → $5 off,” the backend creates a discount code (or selects one from a pre-created pool) via the Admin API, records the reward_claim in Supabase, and returns the code to the user (or associates it with the customer so it appears in Customer Account API). Rate limiting and idempotency (e.g. one claim per reward type per user per period) remain the app’s responsibility.

---

## Comprehensive Analysis

Loyalty redemption flows on Shopify break down into earning, storing, and redeeming value. Earning is already implemented in mood-mnky-command via the orders/paid webhook, Inngest, and the XP ledger. Storing is in Supabase (xp_state, rewards, reward_claims). The gap is redemption: turning stored value (XP/points) into a benefit the customer can use at checkout. Two main patterns appear in the research. First, “code-based” redemption: the app creates a discount code (Admin API) and shows it to the user (or sends it by email); the user applies it at checkout. Second, “pay with points” or automatic application: the checkout or cart is modified to apply a discount equivalent to the redeemed points, often requiring deeper checkout extensibility (e.g. Shopify Plus checkout extensions) or a headless checkout that applies the discount via API. For a first version, code-based redemption is the most portable and works with the current Shopify and Customer Account API model: we create a code, store the mapping in reward_claims, and the customer uses it on the storefront or in a headless flow. The Customer Account API’s ability to surface discount and allocation data supports a consistent “your rewards” experience once we start issuing codes.

Theme app extension patterns for loyalty widgets align with how other apps (e.g. LoyaltyLion) and Shopify’s own docs describe embeds and blocks. App embed blocks are the right vehicle for a global launcher that appears on every page without the merchant placing a block in each section. They can load JavaScript and make fetch requests to the app proxy, so the launcher can call `/apps/mnky/api/balance` when the proxy request includes `logged_in_customer_id`, and display points and level in a drawer or modal. If the customer is not logged in, the launcher can show a call-to-action linking to Verse or to store login. App blocks with `target: "section"` suit “potential points” (product or cart) and optional “rewards/balance” sections in footer or account areas. The “potential points” feature is anonymous and only needs the points-preview endpoint with a subtotal parameter; no customer identity is required. The research did not reveal contradictions between different sources; the main nuance is that app proxy does not forward cookies, so any customer-specific data on the storefront must come from proxy query parameters (which Shopify signs and includes when the customer is logged in).

Strength of evidence is high for the App Proxy authentication and `logged_in_customer_id` behavior (official Shopify docs and changelog). For Customer Account API and discount creation, the documentation is clear and versioned (e.g. 2024-10). Theme app extension structure (blocks vs embeds, assets, schema) is well documented. Limitations include: (1) the exact schema for “app embed” vs “app block” in a single extension can vary by Shopify CLI version, so implementation should verify the target and enabled_on in the extension’s schema; (2) storefronts that are fully headless (e.g. Hydrogen only, no Liquid) do not use theme extensions for the storefront UI—there, loyalty would be implemented entirely in the headless app and APIs (Customer Account API, Storefront API, and our backend). The plan’s scope (native Shopify theme + Verse) is consistent with using both theme extensions and app proxy for the storefront, and Customer Account API for Verse/headless account and checkout flows.

---

## Practical Implications

For immediate implementation, the following are the most actionable conclusions.

**App Proxy balance endpoint:** Implement `GET /apps/mnky/api/balance` (or equivalent under the existing `/apps/mnky` proxy). On each request, verify the proxy signature using the app’s shared secret (same as webhook HMAC verification: sort query params, exclude signature, HMAC-SHA256 with secret, compare). Then read `logged_in_customer_id` from the query string. If present, resolve the profile with `shopify_customer_id` equal to that ID (string comparison; Shopify may send numeric or GID format—document and normalize). Return that profile’s `xp_state` (xp_total, level, updated_at). If `logged_in_customer_id` is missing or empty, return a JSON response indicating the customer is not logged in and include a link to Verse rewards or store login. Do not return data for another customer; the verification step “ensure logged_in_customer_id matches the data returned” is satisfied by only querying by that id. This removes the need for custom signed customer tokens for the storefront-launcher use case.

**Points preview endpoint:** Implement `GET /apps/mnky/api/points-preview?subtotal=...`. Use the same purchase tier logic as the Inngest shopify/order.paid function (from config_xp_rules or default tiers). Return JSON with points and subtotal. No authentication required; optional rate limiting by IP or shop to prevent abuse.

**Theme extension:** Add to `extensions/mood-mnky-theme` an app embed block (launcher) and an app block for “potential points.” The launcher’s Liquid/JS should request the proxy URL for balance (including the proxy’s own query string so Shopify forwards it with signed params). If the response indicates success and includes balance, show it in the drawer; otherwise show “View rewards” linking to the app’s Verse rewards URL. The potential points block can call the points-preview endpoint with the product price or cart total (from Liquid or a cart object if available) and display “Earn X points.”

**Redemption (backend):** When implementing redemption, use the Admin GraphQL API (`discountCodeBasicCreate` or the appropriate discount mutation) with the `write_discounts` scope. Create a single-use or one-per-customer code, store the code and external ref in reward_claims, and deduct XP (or record the claim) in the same transaction. Optionally sync or expose the issued code in the Customer Account API context so headless UIs can show “your active discounts.”

**Customer Account API:** For Verse and any headless flows, configure Customer Account API (OAuth, callback URLs) as already documented in the project. Use it to identify the customer and to surface “my orders” and, once we issue codes, “my rewards/discounts.” This complements the storefront launcher: storefront uses proxy + logged_in_customer_id; Verse uses session + profile id and can call the same balance and rewards APIs with profile context.

**Documentation and security:** Update SHOPIFY-LOYALTY-EXTENSION.md to state that customer identity for the balance endpoint is provided by Shopify via `logged_in_customer_id` on the app proxy request, and that signature verification is required before trusting it. Reference Shopify’s “Authenticate app proxies” and “Calculate a digital signature” documentation. Note that cookies are stripped and that no custom customer token is needed for the proxy path.

---

## References

- Shopify, “Building with the Customer Account API,” https://shopify.dev/docs/storefronts/headless/building-with-the-customer-account-api
- Shopify, “Customer Account API,” https://shopify.dev/docs/api/customer-account-ui-extensions/2024-10/apis/customer-account-api
- Shopify, “Discounts (checkout UI extensions),” https://shopify.dev/docs/api/checkout-ui-extensions/2024-01/apis/discounts
- Shopify, “Authenticate app proxies,” https://shopify.dev/docs/apps/build/online-store/app-proxies/authenticate-app-proxies
- Shopify, “App proxy requests include new parameter for the logged in customer ID,” changelog
- Shopify, “About theme app extensions,” https://shopify-dev.shopifycloud.com/docs/apps/build/online-store/theme-app-extensions
- Shopify, “Configure theme app extensions,” https://shopify.dev/docs/apps/build/online-store/theme-app-extensions/configuration
- Shopify, “priceRuleDiscountCodeCreate / discountCodeBasicCreate,” GraphQL Admin API
- LoyaltyLion, “Enable LoyaltyLion via Shopify App Embeds,” help.loyaltylion.com

This report supports the implementation plan in GAMIFICATION-TOUCHPOINTS.md, GAMIFICATION-GAME-INFRASTRUCTURE.md, and SHOPIFY-LOYALTY-EXTENSION.md and should be updated if Shopify changes proxy or Customer Account API behavior.
