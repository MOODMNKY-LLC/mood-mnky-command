---
title: 'Mono Repo Structure'
description: 'Architecture and organization of the MOOD MNKY mono repository'
---

# Mono Repo Structure

<img
  className="rounded-lg shadow-lg border border-gray-200 max-w-full h-32 mx-auto my-6"
  src="/images/monorepo-structure.svg"
  alt="Mono Repository Structure"
/>

## Overview

The MOOD MNKY ecosystem uses a mono repository architecture to organize all codebase components and ensure consistency across our digital products. This approach allows us to share code, maintain unified standards, and streamline development workflows.

<Note>
  Our mono repo is managed with Turborepo, providing parallel execution, incremental builds, and a structured development experience.
</Note>

## Repository Organization

<CardGroup cols={3}>
  <Card title="Apps" icon="window">
    Next.js app (MNKY VERSE + Dojo + LABZ) in `apps/web/`
  </Card>
  <Card title="Shopify" icon="shopping-bag">
    Liquid theme and theme app extension
  </Card>
  <Card title="Supabase" icon="database">
    Migrations and Edge Functions at repo root
  </Card>
  <Card title="Extensions" icon="puzzle-piece">
    Theme app extension (blocks, embed)
  </Card>
  <Card title="Config" icon="gear">
    Root package.json, turbo.json, pnpm-workspace
  </Card>
</CardGroup>

## Directory Structure

The **mood-mnky-command** monorepo uses a single Next.js application (`apps/web/`) that hosts MNKY VERSE, The Dojo, and MNKY LABZ via route groups:

```bash
mood-mnky-command/
├── apps/
│   └── web/                 # Single Next.js app (MNKY VERSE + Dojo + LABZ)
│       ├── app/
│       │   ├── (storefront)/verse/  # MNKY VERSE routes
│       │   ├── dojo/                # The Dojo routes
│       │   └── (dashboard)/         # MNKY LABZ routes
│       ├── components/
│       └── lib/
│
├── Shopify/
│   └── theme/               # Liquid theme (Dawn-derived)
│
├── extensions/
│   └── mood-mnky-theme/     # Theme app extension (blocks, embed)
│
├── supabase/
│   ├── migrations/          # Database migrations
│   └── functions/           # Edge functions (optional)
│
├── packages/                # Shared packages (workspace supports; add as needed)
│
├── docs/                    # Repo docs (design system, runbooks)
├── mnky-docs/               # Mintlify documentation (this site)
├── .github/                 # GitHub workflows
├── turbo.json               # Turborepo configuration
└── package.json             # Root package.json
```

<Info>
The Supabase config lives in `supabase/` at the repo root. Migrations, Edge Functions, and config are in that directory. Run `supabase start` and `supabase db reset` from the repo root.
</Info>

## Application Structure

The `apps/web/` Next.js app uses the App Router with route groups:

<Tabs>
  <Tab title="apps/web">
    ```bash
    apps/web/
    ├── app/
    │   ├── (storefront)/verse/  # MNKY VERSE
    │   ├── dojo/                # The Dojo
    │   ├── (dashboard)/         # MNKY LABZ
    │   └── api/                 # API routes
    ├── components/
    │   ├── verse/
    │   ├── dojo/
    │   ├── dashboard/
    │   └── labz/
    ├── lib/
    ├── public/
    └── ...
    ```
  </Tab>
  <Tab title="Shopify Theme">
    ```bash
    Shopify/theme/            # Dawn-derived Liquid theme
    ├── sections/
    ├── snippets/
    ├── templates/
    ├── config/
    └── assets/

    extensions/mood-mnky-theme/  # Theme app extension
    ├── blocks/               # App blocks (Blending CTA, etc.)
    └── ...                   # App embed (MNKY CHAT)
    ```
  </Tab>
</Tabs>

## Package Structure

Shared packages follow a consistent structure to make them easy to consume:

```bash
packages/[package-name]/
├── src/
│   └── index.ts            # Main entry point
├── dist/                   # Built output (generated)
├── tests/                  # Tests
├── package.json            # Package metadata and dependencies
└── tsconfig.json           # TypeScript configuration
```

## Infrastructure and Data Organization

Our infrastructure and data follow a clear organization:

<Tabs>
  <Tab title="Supabase">
    ```bash
    # At repo root
    supabase/
    ├── migrations/           # Database migration scripts
    ├── functions/            # Edge functions (optional)
    └── config.toml           # Supabase configuration
    ```
  </Tab>
  <Tab title="Agent Integration">
    Agent logic (MOOD MNKY, CODE MNKY, SAGE MNKY) is integrated in `apps/web/` via Flowise (MNKY CHAT), CODE MNKY in LABZ, and the agents documentation in `mnky-docs/agents/`.
  </Tab>
</Tabs>

## Dependency Management

We use a combination of tools to manage dependencies in our mono repo:

<Steps>
  <Step title="Package Manager">
    pnpm is our primary package manager, chosen for its efficient handling of dependencies in a mono repo structure.
    
    ```bash
    # Installing a dependency in the web app
    pnpm --filter web add react-query
    
    # Installing a root-level dev dependency
    pnpm add -w typescript
    
    # Installing in a workspace package (when packages exist)
    pnpm --filter web add @repo/ui
    ```
  </Step>
  <Step title="Workspace Configuration">
    Our workspaces are configured in pnpm-workspace.yaml:
    
    ```yaml
    packages:
      - 'apps/*'
      - 'packages/*'
    ```
    
    And the root package.json:
    
    ```json
    {
      "name": "mood-mnky",
      "private": true,
      "scripts": {
        "dev": "turbo run dev",
        "build": "turbo run build",
        "test": "turbo run test",
        "lint": "turbo run lint"
      }
    }
    ```
  </Step>
  <Step title="Build System">
    Turborepo orchestrates our build process, enabling incremental builds and task caching.
    
    ```json
    // turbo.json
    {
      "$schema": "https://turbo.build/schema.json",
      "pipeline": {
        "build": {
          "dependsOn": ["^build"],
          "outputs": ["dist/**", ".next/**", "public/dist/**"]
        },
        "test": {
          "dependsOn": ["^build"],
          "outputs": []
        },
        "lint": {
          "outputs": []
        },
        "dev": {
          "cache": false,
          "persistent": true
        }
      }
    }
    ```
  </Step>
</Steps>

## Supabase Integration

The Supabase integration follows our structured organization:

<AccordionGroup>
  <Accordion title="Migrations" icon="code-branch">
    Migrations live in `supabase/migrations/` at the repo root. Each migration is a timestamped SQL file applied in sequence:
    
    ```sql
    -- supabase/migrations/20240401000000_create_users_table.sql
    CREATE TABLE public.users (
      id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
      email TEXT UNIQUE NOT NULL,
      full_name TEXT,
      created_at TIMESTAMP WITH TIME ZONE DEFAULT now(),
      updated_at TIMESTAMP WITH TIME ZONE DEFAULT now()
    );
    ```
    
    Run `supabase db reset` from the repo root to apply all migrations.
  </Accordion>
  
  <Accordion title="Supabase Client" icon="plug">
    The app uses `@supabase/supabase-js` from `apps/web/lib/`. Create clients with `NEXT_PUBLIC_SUPABASE_URL` and `NEXT_PUBLIC_SUPABASE_ANON_KEY` (or `SUPABASE_SERVICE_ROLE_KEY` for server-side).
    
    ```typescript
    import { createClient } from '@supabase/supabase-js';
    
    const supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
    );
    ```
  </Accordion>
</AccordionGroup>

## Development Workflow

Developing in our mono repo follows these principles:

1. **Task Isolation**: Work on isolated features or bugfixes in dedicated branches
2. **Local Development**: Use Turborepo's filtering to run only relevant applications and packages
3. **Dependency Management**: Add shared code to appropriate packages rather than duplicating across apps
4. **Testing**: Write tests for shared packages to ensure reliability across applications
5. **Documentation**: Document shared components and utilities to facilitate reuse

### Setting Up Supabase for Development

To set up Supabase for local development:

<Steps>
  <Step title="Install the Supabase CLI">
    ```bash
    npm install -g supabase
    ```
  </Step>
  <Step title="Start Supabase Local Development">
    ```bash
    # From repo root
    supabase start
    ```
    
    This will start a local Supabase instance with PostgreSQL, Auth, Storage, and other services.
  </Step>
  <Step title="Apply Migrations">
    ```bash
    # Apply all migrations to the local database
    supabase db reset
    ```
    
    This will apply all migrations in the `migrations` directory and reset the database to a clean state.
  </Step>
  <Step title="Seed Data (Optional)">
    ```bash
    # Run seed script if present in supabase/seed.sql
    supabase db reset
    ```
    
    This will populate the database with seed data for development and testing.
  </Step>
</Steps>

### Typical Development Commands

```bash
# Start development server (runs apps/web via turbo)
pnpm dev

# Start development for the web app only
pnpm --filter web dev

# Run lint
pnpm lint

# Create a new Supabase migration (from repo root)
supabase migration new add_new_feature
```

## CI/CD Integration

Our continuous integration pipeline is configured to handle our mono repo structure efficiently:

<Steps>
  <Step title="Change Detection">
    The pipeline detects which packages and apps have changed to determine what needs to be built and tested.
  </Step>
  <Step title="Dependency Analysis">
    It analyzes dependencies to ensure that changes to shared packages trigger builds and tests for dependent apps.
  </Step>
  <Step title="Parallel Execution">
    Build and test jobs run in parallel for independent packages and apps to minimize pipeline time.
  </Step>
  <Step title="Deployment">
    After successful tests, affected applications are deployed to their respective environments.
  </Step>
</Steps>

## Best Practices

<CardGroup cols={3}>
  <Card title="Code Organization" icon="folder-tree">
    - Keep apps and packages focused on specific concerns
    - Extract shared code into dedicated packages
    - Maintain consistent file structure across apps
  </Card>
  <Card title="Dependencies" icon="diagram-project">
    - Minimize dependencies between packages
    - Avoid circular dependencies
    - Properly declare all dependencies in package.json
  </Card>
  <Card title="Performance" icon="gauge-high">
    - Use Turborepo's caching for faster builds
    - Implement code splitting within apps
    - Optimize package sizes
  </Card>
  <Card title="Testing" icon="vial">
    - Write tests for shared packages
    - Use mocks for complex dependencies
    - Ensure tests run in isolation
  </Card>
  <Card title="Documentation" icon="book">
    - Document package APIs and component usage
    - Maintain README files for all packages
    - Use TypeScript for type safety
  </Card>
  <Card title="Versioning" icon="code-compare">
    - Follow SemVer for all packages
    - Document breaking changes
    - Keep package versions in sync when appropriate
  </Card>
</CardGroup>

## Resources

<CardGroup cols={2}>
  <Card title="Turborepo Documentation" icon="book" href="https://turbo.build/repo/docs" target="_blank">
    Official documentation for our build system
  </Card>
  <Card title="pnpm Workspaces" icon="book" href="https://pnpm.io/workspaces" target="_blank">
    Documentation for pnpm workspace features
  </Card>
  <Card title="Internal Architecture Docs" icon="diagram-project" href="/developer-resources/architecture">
    Detailed architecture documentation for the MOOD MNKY ecosystem
  </Card>
  <Card title="Supabase Documentation" icon="database" href="https://supabase.com/docs" target="_blank">
    Official Supabase documentation
  </Card>
</CardGroup>

---

For questions about our mono repo structure, please contact the MOOD MNKY development team.