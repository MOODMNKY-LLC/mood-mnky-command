

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE SCHEMA IF NOT EXISTS "public";


ALTER SCHEMA "public" OWNER TO "pg_database_owner";


COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE TYPE "public"."pricing_plan_interval" AS ENUM (
    'day',
    'week',
    'month',
    'year'
);


ALTER TYPE "public"."pricing_plan_interval" OWNER TO "postgres";


CREATE TYPE "public"."pricing_type" AS ENUM (
    'one_time',
    'recurring'
);


ALTER TYPE "public"."pricing_type" OWNER TO "postgres";


CREATE TYPE "public"."subscription_status" AS ENUM (
    'trialing',
    'active',
    'canceled',
    'incomplete',
    'incomplete_expired',
    'past_due',
    'unpaid'
);


ALTER TYPE "public"."subscription_status" OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."check_current_bucket_update"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  -- your trigger logic here
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."check_current_bucket_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."create_notification"("user_id" "uuid", "title" "text", "message" "text", "type" "text" DEFAULT 'info'::"text", "action_url" "text" DEFAULT NULL::"text", "metadata" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  notification_id uuid;
begin
  insert into public.notifications (user_id, title, message, type, action_url, metadata)
  values (user_id, title, message, type, action_url, metadata)
  returning id into notification_id;
  
  return notification_id;
end;
$$;


ALTER FUNCTION "public"."create_notification"("user_id" "uuid", "title" "text", "message" "text", "type" "text", "action_url" "text", "metadata" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."create_notification"("user_id" "uuid", "title" "text", "message" "text", "type" "text", "action_url" "text", "metadata" "jsonb") IS 'Creates a notification for a specific user.';



CREATE OR REPLACE FUNCTION "public"."create_user_bucket"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$
DECLARE
  bucket_name text;
BEGIN
  -- Generate a bucket name based on the user's ID
  -- Format: user_<user_id>
  bucket_name := 'user_' || replace(NEW.id::text, '-', '_');
  
  -- Check if the bucket already exists
  IF NOT EXISTS (SELECT 1 FROM storage.buckets WHERE name = bucket_name) THEN
    -- Create the storage bucket for the user
    INSERT INTO storage.buckets (id, name, owner, public)
    VALUES (bucket_name, bucket_name, NEW.id, false);
    
    -- Log the creation (optional)
    RAISE NOTICE 'Created new bucket % for user %', bucket_name, NEW.id;
  END IF;
  
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."create_user_bucket"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  new_role text;
begin
  select case when (select count(*) from public.profiles) = 0 then 'admin' else 'pending' end
  into new_role;

  insert into public.profiles (id, display_name, full_name, avatar_url, role, email, last_sign_in_at)
  values (
    new.id,
    coalesce(new.raw_user_meta_data ->> 'display_name', split_part(new.email, '@', 1)),
    new.raw_user_meta_data ->> 'full_name',
    new.raw_user_meta_data ->> 'avatar_url',
    new_role,
    new.email,
    new.last_sign_in_at
  )
  on conflict (id) do nothing;

  return new;
end;
$$;


ALTER FUNCTION "public"."handle_new_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."handle_new_user_settings"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  insert into public.user_settings (user_id)
  values (new.id);
  return new;
end;
$$;


ALTER FUNCTION "public"."handle_new_user_settings"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."handle_new_user_settings"() IS 'Automatically creates default settings when a new user profile is created.';



CREATE OR REPLACE FUNCTION "public"."handle_profile_updated"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


ALTER FUNCTION "public"."handle_profile_updated"() OWNER TO "postgres";


COMMENT ON FUNCTION "public"."handle_profile_updated"() IS 'Automatically updates the updated_at timestamp when a profile is updated.';



CREATE OR REPLACE FUNCTION "public"."hybrid_search"("query_text" "text", "query_embedding" "extensions"."vector", "match_count" integer DEFAULT 10) RETURNS TABLE("id" "text", "title" "text", "content" "text", "metadata" "jsonb", "similarity" double precision, "rank" double precision)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  -- function logic here
END;
$$;


ALTER FUNCTION "public"."hybrid_search"("query_text" "text", "query_embedding" "extensions"."vector", "match_count" integer) OWNER TO "postgres";


COMMENT ON FUNCTION "public"."hybrid_search"("query_text" "text", "query_embedding" "extensions"."vector", "match_count" integer) IS 'Performs hybrid search on documents using both vector embeddings and full-text search.';



CREATE OR REPLACE FUNCTION "public"."increment_workflow_version"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
			BEGIN
				IF NEW."versionCounter" IS NOT DISTINCT FROM OLD."versionCounter" THEN
					NEW."versionCounter" = OLD."versionCounter" + 1;
				END IF;
				RETURN NEW;
			END;
			$$;


ALTER FUNCTION "public"."increment_workflow_version"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."is_admin"() RETURNS boolean
    LANGUAGE "sql" STABLE SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
  select exists (
    select 1 from public.profiles
    where id = auth.uid() and role = 'admin'
  );
$$;


ALTER FUNCTION "public"."is_admin"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."log_user_action"("user_id" "uuid", "action" "text", "details" "jsonb" DEFAULT '{}'::"jsonb") RETURNS "uuid"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
declare
  record_id uuid;
begin
  insert into public.analytics (user_id, event_type, event_data)
  values (user_id, action, details)
  returning id into record_id;
  
  return record_id;
end;
$$;


ALTER FUNCTION "public"."log_user_action"("user_id" "uuid", "action" "text", "details" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."log_user_action"("user_id" "uuid", "action" "text", "details" "jsonb") IS 'Logs user actions for analytics tracking.';



CREATE OR REPLACE FUNCTION "public"."match_documents"("query_embedding" "extensions"."vector", "match_count" integer DEFAULT 10, "filter" "jsonb" DEFAULT '{}'::"jsonb") RETURNS TABLE("id" "text", "title" "text", "content" "text", "metadata" "jsonb", "similarity" double precision)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    documents.id,
    documents.title,
    documents.content,
    documents.metadata,
    1 - (documents.embedding <=> query_embedding) AS similarity
  FROM public.documents
  WHERE documents.metadata @> filter
  ORDER BY documents.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."match_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."match_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") IS 'Performs semantic search on documents using OpenAI embeddings.';



CREATE OR REPLACE FUNCTION "public"."match_ollama_documents"("query_embedding" "extensions"."vector", "match_count" integer DEFAULT 10, "filter" "jsonb" DEFAULT '{}'::"jsonb") RETURNS TABLE("id" "text", "title" "text", "content" "text", "metadata" "jsonb", "similarity" double precision)
    LANGUAGE "plpgsql"
    SET "search_path" TO 'public', 'pg_temp'
    AS $$
BEGIN
  RETURN QUERY
  SELECT
    ollama_documents.id,
    ollama_documents.title,
    ollama_documents.content,
    ollama_documents.metadata,
    1 - (ollama_documents.embedding <=> query_embedding) AS similarity
  FROM public.ollama_documents
  WHERE ollama_documents.metadata @> filter
  ORDER BY ollama_documents.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;


ALTER FUNCTION "public"."match_ollama_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") OWNER TO "postgres";


COMMENT ON FUNCTION "public"."match_ollama_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") IS 'Performs semantic search on documents using Ollama embeddings.';



CREATE OR REPLACE FUNCTION "public"."prevent_non_admin_role_update"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  -- If role is being changed and updater is not admin, reject
  if old.role is distinct from new.role then
    if not exists (
      select 1 from public.profiles where id = auth.uid() and role = 'admin'
    ) then
      raise exception 'Only admins can change user roles';
    end if;
  end if;
  return new;
end;
$$;


ALTER FUNCTION "public"."prevent_non_admin_role_update"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_agent_profiles_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.updated_at := now();
  return new;
end;
$$;


ALTER FUNCTION "public"."set_agent_profiles_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_profiles_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$ begin new.updated_at = now(); return new; end; $$;


ALTER FUNCTION "public"."set_profiles_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO ''
    AS $$ begin new.updated_at = now(); return new; end; $$;


ALTER FUNCTION "public"."set_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."set_updated_at_metadata"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.updated_at = now();
  return NEW;
end;
$$;


ALTER FUNCTION "public"."set_updated_at_metadata"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_is_admin_from_role"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  new.is_admin := (new.role = 'admin');
  return new;
end;
$$;


ALTER FUNCTION "public"."sync_is_admin_from_role"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."sync_profile_from_auth_user"() RETURNS "trigger"
    LANGUAGE "plpgsql" SECURITY DEFINER
    SET "search_path" TO 'public'
    AS $$
begin
  update public.profiles
  set
    email = coalesce(profiles.email, new.email),
    last_sign_in_at = new.last_sign_in_at
  where id = new.id;
  return new;
end;
$$;


ALTER FUNCTION "public"."sync_profile_from_auth_user"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_spotify_recommendations_updated_at"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$;


ALTER FUNCTION "public"."update_spotify_recommendations_updated_at"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."update_updated_at_column"() RETURNS "trigger"
    LANGUAGE "plpgsql"
    AS $$
begin
  new.updated_at = now();
  return new;
end;
$$;


ALTER FUNCTION "public"."update_updated_at_column"() OWNER TO "postgres";


CREATE OR REPLACE FUNCTION "public"."uuid_generate_v4"() RETURNS "uuid"
    LANGUAGE "sql" STABLE
    AS $$SELECT extensions.uuid_generate_v4()$$;


ALTER FUNCTION "public"."uuid_generate_v4"() OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."agent_profiles" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "slug" "text" NOT NULL,
    "display_name" "text" DEFAULT ''::"text" NOT NULL,
    "blurb" "text",
    "image_path" "text",
    "openai_model" "text",
    "openai_voice" "text",
    "system_instructions" "text",
    "tools" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "eleven_labs_agent_id" "text",
    "sort_order" integer DEFAULT 0 NOT NULL,
    "is_active" boolean DEFAULT true NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."agent_profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."agent_profiles" IS 'Verse/Labz chat agent definitions; admin-managed via /chat/agents.';



CREATE TABLE IF NOT EXISTS "public"."ai_agents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "avatar_url" "text",
    "system_prompt" "text" NOT NULL,
    "capabilities" "jsonb" DEFAULT '[]'::"jsonb",
    "is_active" boolean DEFAULT true,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."ai_agents" OWNER TO "postgres";


COMMENT ON TABLE "public"."ai_agents" IS 'Configuration for AI agents in the MNKY-VERSE application. Defines the specialized agents like MOOD MNKY, SAGE MNKY, and CODE MNKY.';



CREATE TABLE IF NOT EXISTS "public"."albums" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "cover_url" "text",
    "navidrome_cover_art_id" "text",
    "primary_artist_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."albums" OWNER TO "postgres";


COMMENT ON TABLE "public"."albums" IS 'Normalized albums; primary_artist_id links to artists.';



CREATE TABLE IF NOT EXISTS "public"."analytics" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid",
    "event_type" "text" NOT NULL,
    "event_data" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."analytics" OWNER TO "postgres";


COMMENT ON TABLE "public"."analytics" IS 'Usage analytics data for the MNKY-VERSE application, tracking user interactions and system events.';



CREATE TABLE IF NOT EXISTS "public"."annotation_tag_entity" (
    "id" character varying(16) NOT NULL,
    "name" character varying(24) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."annotation_tag_entity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."apikey" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "apiKey" character varying NOT NULL,
    "apiSecret" character varying NOT NULL,
    "keyName" character varying NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."apikey" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."artists" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "image_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."artists" OWNER TO "postgres";


COMMENT ON TABLE "public"."artists" IS 'Normalized artists; referenced by albums and track_artists.';



CREATE TABLE IF NOT EXISTS "public"."assistant" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "credential" "uuid" NOT NULL,
    "details" "text" NOT NULL,
    "iconSrc" character varying,
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "type" "text"
);


ALTER TABLE "public"."assistant" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."audio_transcripts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "source_asset_id" "uuid",
    "task_type" "text" NOT NULL,
    "model" "text" NOT NULL,
    "response_format" "text",
    "raw_text" "text",
    "segments" "jsonb",
    "usage_json" "jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "audio_transcripts_task_type_check" CHECK (("task_type" = ANY (ARRAY['transcribe'::"text", 'translate'::"text"])))
);


ALTER TABLE "public"."audio_transcripts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."auth_identity" (
    "userId" "uuid",
    "providerId" character varying(64) NOT NULL,
    "providerType" character varying(32) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."auth_identity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."auth_provider_sync_history" (
    "id" integer NOT NULL,
    "providerType" character varying(32) NOT NULL,
    "runMode" "text" NOT NULL,
    "status" "text" NOT NULL,
    "startedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    "endedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL,
    "scanned" integer NOT NULL,
    "created" integer NOT NULL,
    "updated" integer NOT NULL,
    "disabled" integer NOT NULL,
    "error" "text"
);


ALTER TABLE "public"."auth_provider_sync_history" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."auth_provider_sync_history_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."auth_provider_sync_history_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."auth_provider_sync_history_id_seq" OWNED BY "public"."auth_provider_sync_history"."id";



CREATE TABLE IF NOT EXISTS "public"."binary_data" (
    "fileId" "uuid" NOT NULL,
    "sourceType" character varying(50) NOT NULL,
    "sourceId" character varying(255) NOT NULL,
    "data" "bytea" NOT NULL,
    "mimeType" character varying(255),
    "fileName" character varying(255),
    "fileSize" integer NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    CONSTRAINT "CHK_binary_data_sourceType" CHECK ((("sourceType")::"text" = ANY ((ARRAY['execution'::character varying, 'chat_message_attachment'::character varying])::"text"[])))
);


ALTER TABLE "public"."binary_data" OWNER TO "postgres";


COMMENT ON COLUMN "public"."binary_data"."sourceType" IS 'Source the file belongs to, e.g. ''execution''';



COMMENT ON COLUMN "public"."binary_data"."sourceId" IS 'ID of the source, e.g. execution ID';



COMMENT ON COLUMN "public"."binary_data"."data" IS 'Raw, not base64 encoded';



COMMENT ON COLUMN "public"."binary_data"."fileSize" IS 'In bytes';



CREATE TABLE IF NOT EXISTS "public"."chat_flow" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "name" character varying NOT NULL,
    "flowData" "text" NOT NULL,
    "deployed" boolean,
    "isPublic" boolean,
    "apikeyid" character varying,
    "chatbotConfig" "text",
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "apiConfig" "text",
    "analytic" "text",
    "category" "text",
    "speechToText" "text",
    "type" "text",
    "followUpPrompts" "text"
);


ALTER TABLE "public"."chat_flow" OWNER TO "postgres";


COMMENT ON TABLE "public"."chat_flow" IS 'Table for chat flow';



CREATE TABLE IF NOT EXISTS "public"."chat_hub_agents" (
    "id" "uuid" NOT NULL,
    "name" character varying(256) NOT NULL,
    "description" character varying(512),
    "systemPrompt" "text" NOT NULL,
    "ownerId" "uuid" NOT NULL,
    "credentialId" character varying(36),
    "provider" character varying(16) NOT NULL,
    "model" character varying(64) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "tools" "json" DEFAULT '[]'::"json" NOT NULL,
    "icon" "json"
);


ALTER TABLE "public"."chat_hub_agents" OWNER TO "postgres";


COMMENT ON COLUMN "public"."chat_hub_agents"."provider" IS 'ChatHubProvider enum: "openai", "anthropic", "google", "n8n"';



COMMENT ON COLUMN "public"."chat_hub_agents"."model" IS 'Model name used at the respective Model node, ie. "gpt-4"';



COMMENT ON COLUMN "public"."chat_hub_agents"."tools" IS 'Tools available to the agent as JSON node definitions';



CREATE TABLE IF NOT EXISTS "public"."chat_hub_messages" (
    "id" "uuid" NOT NULL,
    "sessionId" "uuid" NOT NULL,
    "previousMessageId" "uuid",
    "revisionOfMessageId" "uuid",
    "retryOfMessageId" "uuid",
    "type" character varying(16) NOT NULL,
    "name" character varying(128) NOT NULL,
    "content" "text" NOT NULL,
    "provider" character varying(16),
    "model" character varying(256),
    "workflowId" character varying(36),
    "executionId" integer,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "agentId" "uuid",
    "status" character varying(16) DEFAULT 'success'::character varying NOT NULL,
    "attachments" "json"
);


ALTER TABLE "public"."chat_hub_messages" OWNER TO "postgres";


COMMENT ON COLUMN "public"."chat_hub_messages"."type" IS 'ChatHubMessageType enum: "human", "ai", "system", "tool", "generic"';



COMMENT ON COLUMN "public"."chat_hub_messages"."provider" IS 'ChatHubProvider enum: "openai", "anthropic", "google", "n8n"';



COMMENT ON COLUMN "public"."chat_hub_messages"."model" IS 'Model name used at the respective Model node, ie. "gpt-4"';



COMMENT ON COLUMN "public"."chat_hub_messages"."agentId" IS 'ID of the custom agent (if provider is "custom-agent")';



COMMENT ON COLUMN "public"."chat_hub_messages"."status" IS 'ChatHubMessageStatus enum, eg. "success", "error", "running", "cancelled"';



COMMENT ON COLUMN "public"."chat_hub_messages"."attachments" IS 'File attachments for the message (if any), stored as JSON. Files are stored as base64-encoded data URLs.';



CREATE TABLE IF NOT EXISTS "public"."chat_hub_sessions" (
    "id" "uuid" NOT NULL,
    "title" character varying(256) NOT NULL,
    "ownerId" "uuid" NOT NULL,
    "lastMessageAt" timestamp(3) with time zone NOT NULL,
    "credentialId" character varying(36),
    "provider" character varying(16),
    "model" character varying(256),
    "workflowId" character varying(36),
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "agentId" "uuid",
    "agentName" character varying(128),
    "tools" "json" DEFAULT '[]'::"json" NOT NULL
);


ALTER TABLE "public"."chat_hub_sessions" OWNER TO "postgres";


COMMENT ON COLUMN "public"."chat_hub_sessions"."provider" IS 'ChatHubProvider enum: "openai", "anthropic", "google", "n8n"';



COMMENT ON COLUMN "public"."chat_hub_sessions"."model" IS 'Model name used at the respective Model node, ie. "gpt-4"';



COMMENT ON COLUMN "public"."chat_hub_sessions"."agentId" IS 'ID of the custom agent (if provider is "custom-agent")';



COMMENT ON COLUMN "public"."chat_hub_sessions"."agentName" IS 'Cached name of the custom agent (if provider is "custom-agent")';



COMMENT ON COLUMN "public"."chat_hub_sessions"."tools" IS 'Tools available to the agent as JSON node definitions';



CREATE TABLE IF NOT EXISTS "public"."chat_message" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "role" character varying NOT NULL,
    "chatflowid" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "sourceDocuments" "text",
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "chatType" character varying DEFAULT 'INTERNAL'::character varying NOT NULL,
    "chatId" character varying NOT NULL,
    "memoryType" character varying,
    "sessionId" character varying,
    "usedTools" "text",
    "fileAnnotations" "text",
    "fileUploads" "text",
    "leadEmail" "text",
    "agentReasoning" "text",
    "action" "text",
    "artifacts" "text",
    "followUpPrompts" "text"
);


ALTER TABLE "public"."chat_message" OWNER TO "postgres";


COMMENT ON TABLE "public"."chat_message" IS 'Table for chat message';



CREATE TABLE IF NOT EXISTS "public"."chat_message_feedback" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "chatflowid" "uuid" NOT NULL,
    "content" "text",
    "chatId" character varying NOT NULL,
    "messageId" "uuid" NOT NULL,
    "rating" character varying NOT NULL,
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."chat_message_feedback" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."chat_messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "session_id" "uuid" NOT NULL,
    "role" "text" NOT NULL,
    "content" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "attachments" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    CONSTRAINT "chat_messages_role_check" CHECK (("role" = ANY (ARRAY['user'::"text", 'assistant'::"text", 'system'::"text"])))
);


ALTER TABLE "public"."chat_messages" OWNER TO "postgres";


COMMENT ON TABLE "public"."chat_messages" IS 'Messages in a chat session; used to inject recent context into system prompt.';



COMMENT ON COLUMN "public"."chat_messages"."role" IS 'Message role for LLM context.';



COMMENT ON COLUMN "public"."chat_messages"."attachments" IS 'For user messages: array of { url, filename, mediaType } for durable attachment display.';



CREATE TABLE IF NOT EXISTS "public"."chat_sessions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."chat_sessions" OWNER TO "postgres";


COMMENT ON TABLE "public"."chat_sessions" IS 'One per conversation; used for persistence and loading last N messages.';



COMMENT ON COLUMN "public"."chat_sessions"."user_id" IS 'Owner; must equal auth.uid() for RLS.';



COMMENT ON COLUMN "public"."chat_sessions"."title" IS 'Optional human-readable title for the conversation.';



CREATE TABLE IF NOT EXISTS "public"."conversations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "agent_id" "uuid" NOT NULL,
    "title" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "is_pinned" boolean DEFAULT false,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb"
);


ALTER TABLE "public"."conversations" OWNER TO "postgres";


COMMENT ON TABLE "public"."conversations" IS 'User conversations with AI agents. Each conversation groups a series of messages between a user and an agent.';



CREATE TABLE IF NOT EXISTS "public"."credential" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "name" character varying NOT NULL,
    "credentialName" character varying NOT NULL,
    "encryptedData" "text" NOT NULL,
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."credential" OWNER TO "postgres";


COMMENT ON TABLE "public"."credential" IS 'Table for credential';



CREATE TABLE IF NOT EXISTS "public"."credentials_entity" (
    "name" character varying(128) NOT NULL,
    "data" "text" NOT NULL,
    "type" character varying(128) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "id" character varying(36) NOT NULL,
    "isManaged" boolean DEFAULT false NOT NULL,
    "isGlobal" boolean DEFAULT false NOT NULL,
    "isResolvable" boolean DEFAULT false NOT NULL,
    "resolvableAllowFallback" boolean DEFAULT false NOT NULL,
    "resolverId" character varying(16)
);


ALTER TABLE "public"."credentials_entity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."custom_template" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "name" character varying NOT NULL,
    "flowData" "text" NOT NULL,
    "description" character varying,
    "badge" character varying,
    "framework" character varying,
    "usecases" character varying,
    "type" character varying,
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."custom_template" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."custom_voices" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "consent_id" "uuid" NOT NULL,
    "openai_voice_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."custom_voices" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."customer_account_code_verifiers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "state" "text" NOT NULL,
    "verifier" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."customer_account_code_verifiers" OWNER TO "postgres";


COMMENT ON TABLE "public"."customer_account_code_verifiers" IS 'Temporary PKCE code verifiers for Customer Account API OAuth flow. Prune rows older than 10 minutes.';



CREATE TABLE IF NOT EXISTS "public"."customer_account_tokens" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "shop" "text" NOT NULL,
    "access_token" "text" NOT NULL,
    "expires_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."customer_account_tokens" OWNER TO "postgres";


COMMENT ON TABLE "public"."customer_account_tokens" IS 'Customer Account API access tokens. Session cookie stores token id.';



CREATE TABLE IF NOT EXISTS "public"."customers" (
    "id" "uuid" NOT NULL,
    "stripe_customer_id" "text"
);


ALTER TABLE "public"."customers" OWNER TO "postgres";


COMMENT ON TABLE "public"."customers" IS 'Stripe customer id per user.';



CREATE TABLE IF NOT EXISTS "public"."data_table" (
    "id" character varying(36) NOT NULL,
    "name" character varying(128) NOT NULL,
    "projectId" character varying(36) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."data_table" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."data_table_column" (
    "id" character varying(36) NOT NULL,
    "name" character varying(128) NOT NULL,
    "type" character varying(32) NOT NULL,
    "index" integer NOT NULL,
    "dataTableId" character varying(36) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."data_table_column" OWNER TO "postgres";


COMMENT ON COLUMN "public"."data_table_column"."type" IS 'Expected: string, number, boolean, or date (not enforced as a constraint)';



COMMENT ON COLUMN "public"."data_table_column"."index" IS 'Column order, starting from 0 (0 = first column)';



CREATE TABLE IF NOT EXISTS "public"."document_store" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "name" character varying NOT NULL,
    "description" character varying,
    "loaders" "text",
    "whereUsed" "text",
    "status" character varying NOT NULL,
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "vectorStoreConfig" "text",
    "embeddingConfig" "text",
    "recordManagerConfig" "text"
);


ALTER TABLE "public"."document_store" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."document_store_file_chunk" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "docId" "uuid" NOT NULL,
    "chunkNo" integer NOT NULL,
    "storeId" "uuid" NOT NULL,
    "pageContent" "text",
    "metadata" "text"
);


ALTER TABLE "public"."document_store_file_chunk" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."documents" (
    "id" "text" NOT NULL,
    "title" "text",
    "content" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "embedding" "extensions"."vector"(1536),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source" "text",
    "is_public" boolean DEFAULT true
);


ALTER TABLE "public"."documents" OWNER TO "postgres";


COMMENT ON TABLE "public"."documents" IS 'Knowledge base documents with embeddings for semantic search using OpenAI ada-002 (1536 dimensions).';



CREATE TABLE IF NOT EXISTS "public"."dynamic_credential_entry" (
    "credential_id" character varying(16) NOT NULL,
    "subject_id" character varying(16) NOT NULL,
    "resolver_id" character varying(16) NOT NULL,
    "data" "text" NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."dynamic_credential_entry" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."dynamic_credential_resolver" (
    "id" character varying(16) NOT NULL,
    "name" character varying(128) NOT NULL,
    "type" character varying(128) NOT NULL,
    "config" "text" NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."dynamic_credential_resolver" OWNER TO "postgres";


COMMENT ON COLUMN "public"."dynamic_credential_resolver"."config" IS 'Encrypted resolver configuration (JSON encrypted as string)';



CREATE TABLE IF NOT EXISTS "public"."event_destinations" (
    "id" "uuid" NOT NULL,
    "destination" "jsonb" NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."event_destinations" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."execution_annotation_tags" (
    "annotationId" integer NOT NULL,
    "tagId" character varying(24) NOT NULL
);


ALTER TABLE "public"."execution_annotation_tags" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."execution_annotations" (
    "id" integer NOT NULL,
    "executionId" integer NOT NULL,
    "vote" character varying(6),
    "note" "text",
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."execution_annotations" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."execution_annotations_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."execution_annotations_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."execution_annotations_id_seq" OWNED BY "public"."execution_annotations"."id";



CREATE TABLE IF NOT EXISTS "public"."execution_data" (
    "executionId" integer NOT NULL,
    "workflowData" "json" NOT NULL,
    "data" "text" NOT NULL,
    "workflowVersionId" character varying(36)
);


ALTER TABLE "public"."execution_data" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."execution_entity" (
    "id" integer NOT NULL,
    "finished" boolean NOT NULL,
    "mode" character varying NOT NULL,
    "retryOf" character varying,
    "retrySuccessId" character varying,
    "startedAt" timestamp(3) with time zone,
    "stoppedAt" timestamp(3) with time zone,
    "waitTill" timestamp(3) with time zone,
    "status" character varying NOT NULL,
    "workflowId" character varying(36) NOT NULL,
    "deletedAt" timestamp(3) with time zone,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "storedAt" character varying(2) DEFAULT 'db'::character varying NOT NULL,
    CONSTRAINT "execution_entity_storedAt_check" CHECK ((("storedAt")::"text" = ANY ((ARRAY['db'::character varying, 'fs'::character varying, 's3'::character varying])::"text"[])))
);


ALTER TABLE "public"."execution_entity" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."execution_entity_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."execution_entity_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."execution_entity_id_seq" OWNED BY "public"."execution_entity"."id";



CREATE TABLE IF NOT EXISTS "public"."execution_metadata" (
    "id" integer NOT NULL,
    "executionId" integer NOT NULL,
    "key" character varying(255) NOT NULL,
    "value" "text" NOT NULL
);


ALTER TABLE "public"."execution_metadata" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."execution_metadata_temp_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."execution_metadata_temp_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."execution_metadata_temp_id_seq" OWNED BY "public"."execution_metadata"."id";



CREATE TABLE IF NOT EXISTS "public"."folder" (
    "id" character varying(36) NOT NULL,
    "name" character varying(128) NOT NULL,
    "parentFolderId" character varying(36),
    "projectId" character varying(36) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."folder" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."folder_tag" (
    "folderId" character varying(36) NOT NULL,
    "tagId" character varying(36) NOT NULL
);


ALTER TABLE "public"."folder_tag" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."formula_categories" (
    "id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "sort_order" integer DEFAULT 0
);


ALTER TABLE "public"."formula_categories" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."formula_ingredients" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "phase_id" "uuid" NOT NULL,
    "sort_order" integer DEFAULT 0 NOT NULL,
    "name" "text" NOT NULL,
    "function" "text" DEFAULT 'See tutorial'::"text",
    "percentage" numeric NOT NULL,
    "is_fragrance_oil" boolean DEFAULT false
);


ALTER TABLE "public"."formula_ingredients" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."formula_phases" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "formula_id" "uuid" NOT NULL,
    "sort_order" integer DEFAULT 0 NOT NULL,
    "name" "text" NOT NULL
);


ALTER TABLE "public"."formula_phases" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."formulas" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description" "text" DEFAULT ''::"text",
    "category_id" "text" NOT NULL,
    "total_weight_g" numeric DEFAULT 250 NOT NULL,
    "source" "text" DEFAULT 'whole-elise'::"text" NOT NULL,
    "external_url" "text",
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "formulas_source_check" CHECK (("source" = ANY (ARRAY['whole-elise'::"text", 'mood-mnky'::"text", 'custom'::"text"])))
);


ALTER TABLE "public"."formulas" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."fragrance_blends" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "fragrance_oil_id" "uuid" NOT NULL,
    "blends_with_name" "text" NOT NULL,
    "blends_with_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."fragrance_blends" OWNER TO "postgres";


COMMENT ON TABLE "public"."fragrance_blends" IS 'Junction table for fragrance blends well with relationships';



COMMENT ON COLUMN "public"."fragrance_blends"."fragrance_oil_id" IS 'Reference to fragrance oil';



COMMENT ON COLUMN "public"."fragrance_blends"."blends_with_name" IS 'Name of fragrance this blends well with';



COMMENT ON COLUMN "public"."fragrance_blends"."blends_with_url" IS 'URL of the blending fragrance';



CREATE TABLE IF NOT EXISTS "public"."fragrance_notes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "description_short" "text" DEFAULT ''::"text",
    "olfactive_profile" "text" DEFAULT ''::"text",
    "facts" "text" DEFAULT ''::"text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."fragrance_notes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."fragrance_oils" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text" NOT NULL,
    "name" "text" NOT NULL,
    "description" "text" DEFAULT ''::"text",
    "family" "text" DEFAULT ''::"text",
    "type" "text" DEFAULT 'Fragrance Oil'::"text",
    "subfamilies" "text"[] DEFAULT '{}'::"text"[],
    "top_notes" "text"[] DEFAULT '{}'::"text"[],
    "middle_notes" "text"[] DEFAULT '{}'::"text"[],
    "base_notes" "text"[] DEFAULT '{}'::"text"[],
    "alternative_branding" "text"[] DEFAULT '{}'::"text"[],
    "blends_well_with" "text"[] DEFAULT '{}'::"text"[],
    "suggested_colors" "text"[] DEFAULT '{}'::"text"[],
    "candle_safe" boolean DEFAULT true,
    "soap_safe" boolean DEFAULT false,
    "lotion_safe" boolean DEFAULT false,
    "perfume_safe" boolean DEFAULT false,
    "room_spray_safe" boolean DEFAULT false,
    "wax_melt_safe" boolean DEFAULT false,
    "max_usage_candle" numeric DEFAULT 0,
    "max_usage_soap" numeric DEFAULT 0,
    "max_usage_lotion" numeric DEFAULT 0,
    "price_1oz" numeric DEFAULT 0,
    "price_4oz" numeric DEFAULT 0,
    "price_16oz" numeric DEFAULT 0,
    "rating" numeric DEFAULT 0,
    "review_count" numeric DEFAULT 0,
    "allergen_statement" "text",
    "notion_url" "text",
    "last_edited_at" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "image_url" "text",
    "image_source" "text"
);


ALTER TABLE "public"."fragrance_oils" OWNER TO "postgres";


COMMENT ON COLUMN "public"."fragrance_oils"."image_url" IS 'CDN URL for fragrance scene/image';



COMMENT ON COLUMN "public"."fragrance_oils"."image_source" IS 'notion | supabase | ai-generated';



CREATE TABLE IF NOT EXISTS "public"."fragrance_reviews" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "fragrance_oil_id" "uuid" NOT NULL,
    "rating" integer NOT NULL,
    "reviewer_name" "text",
    "review_date" "date",
    "review_text" "text",
    "helpful_count" integer DEFAULT 0,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "fragrance_reviews_rating_check" CHECK ((("rating" >= 1) AND ("rating" <= 5)))
);


ALTER TABLE "public"."fragrance_reviews" OWNER TO "postgres";


COMMENT ON TABLE "public"."fragrance_reviews" IS 'Customer reviews for fragrance oils';



COMMENT ON COLUMN "public"."fragrance_reviews"."fragrance_oil_id" IS 'Reference to fragrance oil';



COMMENT ON COLUMN "public"."fragrance_reviews"."rating" IS 'Review rating (1-5 stars)';



COMMENT ON COLUMN "public"."fragrance_reviews"."reviewer_name" IS 'Name of reviewer';



COMMENT ON COLUMN "public"."fragrance_reviews"."review_date" IS 'Date of review';



COMMENT ON COLUMN "public"."fragrance_reviews"."review_text" IS 'Review text content';



COMMENT ON COLUMN "public"."fragrance_reviews"."helpful_count" IS 'Number of helpful votes';



CREATE TABLE IF NOT EXISTS "public"."funnel_answers" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "run_id" "uuid" NOT NULL,
    "question_key" "text" NOT NULL,
    "answer" "jsonb" DEFAULT '{}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."funnel_answers" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."funnel_definitions" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "name" "text" NOT NULL,
    "description" "text",
    "provider" "text" DEFAULT 'jotform'::"text" NOT NULL,
    "provider_form_id" "text",
    "webhook_id" "text",
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "created_by" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "question_mapping" "jsonb" DEFAULT '{}'::"jsonb",
    "sandbox" boolean DEFAULT false,
    "form_schema" "jsonb" DEFAULT '[]'::"jsonb",
    CONSTRAINT "funnel_definitions_provider_check" CHECK (("provider" = 'jotform'::"text")),
    CONSTRAINT "funnel_definitions_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'active'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."funnel_definitions" OWNER TO "postgres";


COMMENT ON COLUMN "public"."funnel_definitions"."form_schema" IS 'Array of { type, text, order, required, options?, semanticKey? } for native form rendering. Excludes hidden run_id/user_id.';



CREATE TABLE IF NOT EXISTS "public"."funnel_events" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "run_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "payload" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "funnel_events_type_check" CHECK (("type" = ANY (ARRAY['webhook_received'::"text", 'ai_enriched'::"text", 'shopify_pushed'::"text", 'notion_synced'::"text"])))
);


ALTER TABLE "public"."funnel_events" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."funnel_runs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "funnel_id" "uuid" NOT NULL,
    "user_id" "uuid",
    "status" "text" DEFAULT 'started'::"text" NOT NULL,
    "provider_submission_id" "text",
    "started_at" timestamp with time zone DEFAULT "now"(),
    "submitted_at" timestamp with time zone,
    "context" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "funnel_runs_status_check" CHECK (("status" = ANY (ARRAY['started'::"text", 'submitted'::"text", 'abandoned'::"text"])))
);


ALTER TABLE "public"."funnel_runs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."insights_by_period" (
    "id" integer NOT NULL,
    "metaId" integer NOT NULL,
    "type" integer NOT NULL,
    "value" bigint NOT NULL,
    "periodUnit" integer NOT NULL,
    "periodStart" timestamp(0) with time zone DEFAULT CURRENT_TIMESTAMP
);


ALTER TABLE "public"."insights_by_period" OWNER TO "postgres";


COMMENT ON COLUMN "public"."insights_by_period"."type" IS '0: time_saved_minutes, 1: runtime_milliseconds, 2: success, 3: failure';



COMMENT ON COLUMN "public"."insights_by_period"."periodUnit" IS '0: hour, 1: day, 2: week';



ALTER TABLE "public"."insights_by_period" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."insights_by_period_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."insights_metadata" (
    "metaId" integer NOT NULL,
    "workflowId" character varying(36),
    "projectId" character varying(36),
    "workflowName" character varying(128) NOT NULL,
    "projectName" character varying(255) NOT NULL
);


ALTER TABLE "public"."insights_metadata" OWNER TO "postgres";


ALTER TABLE "public"."insights_metadata" ALTER COLUMN "metaId" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."insights_metadata_metaId_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."insights_raw" (
    "id" integer NOT NULL,
    "metaId" integer NOT NULL,
    "type" integer NOT NULL,
    "value" bigint NOT NULL,
    "timestamp" timestamp(0) with time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
);


ALTER TABLE "public"."insights_raw" OWNER TO "postgres";


COMMENT ON COLUMN "public"."insights_raw"."type" IS '0: time_saved_minutes, 1: runtime_milliseconds, 2: success, 3: failure';



ALTER TABLE "public"."insights_raw" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."insights_raw_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."installed_nodes" (
    "name" character varying(200) NOT NULL,
    "type" character varying(200) NOT NULL,
    "latestVersion" integer DEFAULT 1 NOT NULL,
    "package" character varying(241) NOT NULL
);


ALTER TABLE "public"."installed_nodes" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."installed_packages" (
    "packageName" character varying(214) NOT NULL,
    "installedVersion" character varying(50) NOT NULL,
    "authorName" character varying(70),
    "authorEmail" character varying(70),
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."installed_packages" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."invalid_auth_token" (
    "token" character varying(512) NOT NULL,
    "expiresAt" timestamp(3) with time zone NOT NULL
);


ALTER TABLE "public"."invalid_auth_token" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."lead" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "chatflowid" character varying NOT NULL,
    "chatId" character varying NOT NULL,
    "name" "text",
    "email" "text",
    "phone" "text",
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."lead" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."liked_navidrome_tracks" (
    "user_id" "uuid" NOT NULL,
    "navidrome_track_id" "text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."liked_navidrome_tracks" OWNER TO "postgres";


COMMENT ON TABLE "public"."liked_navidrome_tracks" IS 'User likes for Navidrome (Subsonic) tracks.';



CREATE TABLE IF NOT EXISTS "public"."liked_songs" (
    "created_at" timestamp with time zone DEFAULT "now"(),
    "song_id" bigint NOT NULL,
    "user_id" "uuid" NOT NULL
);


ALTER TABLE "public"."liked_songs" OWNER TO "postgres";


COMMENT ON TABLE "public"."liked_songs" IS 'User likes for songs.';



CREATE TABLE IF NOT EXISTS "public"."likes" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "playlist_id" "uuid",
    "track_id" "uuid",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    CONSTRAINT "likes_target_check" CHECK (((("playlist_id" IS NOT NULL) AND ("track_id" IS NULL)) OR (("playlist_id" IS NULL) AND ("track_id" IS NOT NULL))))
);


ALTER TABLE "public"."likes" OWNER TO "postgres";


COMMENT ON TABLE "public"."likes" IS 'User likes: exactly one of playlist_id or track_id per row.';



CREATE TABLE IF NOT EXISTS "public"."listening_history" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "track_id" "uuid" NOT NULL,
    "played_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."listening_history" OWNER TO "postgres";


COMMENT ON TABLE "public"."listening_history" IS 'When a user played a track; for history and recommendations.';



CREATE TABLE IF NOT EXISTS "public"."media_assets" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "bucket_id" "text" NOT NULL,
    "storage_path" "text" NOT NULL,
    "file_name" "text" NOT NULL,
    "mime_type" "text",
    "file_size" bigint,
    "width" integer,
    "height" integer,
    "tags" "text"[] DEFAULT '{}'::"text"[],
    "alt_text" "text",
    "description" "text",
    "linked_entity_type" "text",
    "linked_entity_id" "text",
    "public_url" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "category" "text",
    "source_model" "text",
    "generation_prompt" "text",
    "shopify_product_id" bigint,
    "shopify_image_id" bigint,
    "duration_seconds" numeric,
    "audio_codec" "text",
    "sample_rate" integer,
    "tts_voice_id" "text",
    "tts_model" "text",
    "tts_instructions" "text",
    "tts_speed" numeric,
    "audio_title" "text",
    "audio_artist" "text",
    "audio_album" "text",
    "cover_art_path" "text",
    "cover_art_url" "text"
);


ALTER TABLE "public"."media_assets" OWNER TO "postgres";


COMMENT ON COLUMN "public"."media_assets"."category" IS 'e.g. fragrance-scene, product, mascot';



COMMENT ON COLUMN "public"."media_assets"."source_model" IS 'e.g. gpt-image-1.5';



COMMENT ON COLUMN "public"."media_assets"."generation_prompt" IS 'Prompt used for AI-generated images';



COMMENT ON COLUMN "public"."media_assets"."duration_seconds" IS 'Duration in seconds for audio/video';



COMMENT ON COLUMN "public"."media_assets"."audio_codec" IS 'e.g. mp3, wav, opus';



COMMENT ON COLUMN "public"."media_assets"."tts_voice_id" IS 'Built-in voice name or custom voice OpenAI ID';



COMMENT ON COLUMN "public"."media_assets"."tts_model" IS 'e.g. gpt-4o-mini-tts';



COMMENT ON COLUMN "public"."media_assets"."audio_title" IS 'Extracted from ID3/Vorbis/MP4 tags';



COMMENT ON COLUMN "public"."media_assets"."audio_artist" IS 'Extracted from ID3/Vorbis/MP4 tags';



COMMENT ON COLUMN "public"."media_assets"."audio_album" IS 'Extracted from ID3/Vorbis/MP4 tags';



COMMENT ON COLUMN "public"."media_assets"."cover_art_path" IS 'Storage path for extracted cover art';



COMMENT ON COLUMN "public"."media_assets"."cover_art_url" IS 'Public URL for cover art';



CREATE TABLE IF NOT EXISTS "public"."messages" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "conversation_id" "uuid" NOT NULL,
    "sender_type" "text" NOT NULL,
    "sender_id" "uuid" NOT NULL,
    "content" "text" NOT NULL,
    "embedding" "extensions"."vector"(1536),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "messages_sender_type_check" CHECK (("sender_type" = ANY (ARRAY['user'::"text", 'agent'::"text"])))
);


ALTER TABLE "public"."messages" OWNER TO "postgres";


COMMENT ON TABLE "public"."messages" IS 'Individual messages exchanged between users and AI agents within conversations.';



CREATE TABLE IF NOT EXISTS "public"."migrations" (
    "id" integer NOT NULL,
    "timestamp" bigint NOT NULL,
    "name" character varying NOT NULL
);


ALTER TABLE "public"."migrations" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."migrations_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."migrations_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."migrations_id_seq" OWNED BY "public"."migrations"."id";



CREATE TABLE IF NOT EXISTS "public"."music_requests" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "type" "text" NOT NULL,
    "lidarr_id" "text",
    "title" "text" NOT NULL,
    "artist_name" "text",
    "status" "text" DEFAULT 'requested'::"text" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "music_requests_status_check" CHECK (("status" = ANY (ARRAY['requested'::"text", 'available'::"text"]))),
    CONSTRAINT "music_requests_type_check" CHECK (("type" = ANY (ARRAY['artist'::"text", 'album'::"text"])))
);


ALTER TABLE "public"."music_requests" OWNER TO "postgres";


COMMENT ON TABLE "public"."music_requests" IS 'User music requests via Lidarr; for history and status display.';



CREATE TABLE IF NOT EXISTS "public"."notifications" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "title" "text" NOT NULL,
    "message" "text" NOT NULL,
    "type" "text" NOT NULL,
    "is_read" boolean DEFAULT false,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "action_url" "text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    CONSTRAINT "notifications_type_check" CHECK (("type" = ANY (ARRAY['info'::"text", 'success'::"text", 'warning'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."notifications" OWNER TO "postgres";


COMMENT ON TABLE "public"."notifications" IS 'User notifications for various system events and updates.';



CREATE TABLE IF NOT EXISTS "public"."oauth_access_tokens" (
    "token" character varying NOT NULL,
    "clientId" character varying NOT NULL,
    "userId" "uuid" NOT NULL
);


ALTER TABLE "public"."oauth_access_tokens" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."oauth_authorization_codes" (
    "code" character varying(255) NOT NULL,
    "clientId" character varying NOT NULL,
    "userId" "uuid" NOT NULL,
    "redirectUri" character varying NOT NULL,
    "codeChallenge" character varying NOT NULL,
    "codeChallengeMethod" character varying(255) NOT NULL,
    "expiresAt" bigint NOT NULL,
    "state" character varying,
    "used" boolean DEFAULT false NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."oauth_authorization_codes" OWNER TO "postgres";


COMMENT ON COLUMN "public"."oauth_authorization_codes"."expiresAt" IS 'Unix timestamp in milliseconds';



CREATE TABLE IF NOT EXISTS "public"."oauth_clients" (
    "id" character varying NOT NULL,
    "name" character varying(255) NOT NULL,
    "redirectUris" "json" NOT NULL,
    "grantTypes" "json" NOT NULL,
    "clientSecret" character varying(255),
    "clientSecretExpiresAt" bigint,
    "tokenEndpointAuthMethod" character varying(255) DEFAULT 'none'::character varying NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."oauth_clients" OWNER TO "postgres";


COMMENT ON COLUMN "public"."oauth_clients"."tokenEndpointAuthMethod" IS 'Possible values: none, client_secret_basic or client_secret_post';



CREATE TABLE IF NOT EXISTS "public"."oauth_refresh_tokens" (
    "token" character varying(255) NOT NULL,
    "clientId" character varying NOT NULL,
    "userId" "uuid" NOT NULL,
    "expiresAt" bigint NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."oauth_refresh_tokens" OWNER TO "postgres";


COMMENT ON COLUMN "public"."oauth_refresh_tokens"."expiresAt" IS 'Unix timestamp in milliseconds';



CREATE TABLE IF NOT EXISTS "public"."oauth_user_consents" (
    "id" integer NOT NULL,
    "userId" "uuid" NOT NULL,
    "clientId" character varying NOT NULL,
    "grantedAt" bigint NOT NULL
);


ALTER TABLE "public"."oauth_user_consents" OWNER TO "postgres";


COMMENT ON COLUMN "public"."oauth_user_consents"."grantedAt" IS 'Unix timestamp in milliseconds';



ALTER TABLE "public"."oauth_user_consents" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."oauth_user_consents_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."ollama_documents" (
    "id" "text" NOT NULL,
    "title" "text",
    "content" "text" NOT NULL,
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "embedding" "extensions"."vector"(768),
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "source" "text",
    "is_public" boolean DEFAULT true
);


ALTER TABLE "public"."ollama_documents" OWNER TO "postgres";


COMMENT ON TABLE "public"."ollama_documents" IS 'Knowledge base documents with embeddings for semantic search using Ollama (768 dimensions).';



CREATE TABLE IF NOT EXISTS "public"."pending_logins" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "short_code" "text" NOT NULL,
    "status" "text" DEFAULT 'pending'::"text" NOT NULL,
    "user_id" "uuid",
    "access_token" "text",
    "refresh_token" "text",
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "expires_at" timestamp with time zone NOT NULL,
    "consumed_at" timestamp with time zone,
    CONSTRAINT "pending_logins_status_check" CHECK (("status" = ANY (ARRAY['pending'::"text", 'approved'::"text", 'consumed'::"text", 'expired'::"text"])))
);


ALTER TABLE "public"."pending_logins" OWNER TO "postgres";


COMMENT ON TABLE "public"."pending_logins" IS 'One-time device-code flow: desktop shows QR with code, phone approves, desktop receives session. Server-only.';



CREATE TABLE IF NOT EXISTS "public"."playlist_tracks" (
    "playlist_id" "uuid" NOT NULL,
    "track_id" "uuid" NOT NULL,
    "position" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."playlist_tracks" OWNER TO "postgres";


COMMENT ON TABLE "public"."playlist_tracks" IS 'Tracks in a playlist with ordering; position determines order.';



CREATE TABLE IF NOT EXISTS "public"."playlists" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "owner_id" "uuid",
    "title" "text" NOT NULL,
    "color_accent" "text",
    "color_dark" "text",
    "cover_url" "text",
    "artist_names" "text"[] DEFAULT '{}'::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."playlists" OWNER TO "postgres";


COMMENT ON TABLE "public"."playlists" IS 'Playlists: user-created (owner_id set) or featured/system (owner_id null).';



CREATE TABLE IF NOT EXISTS "public"."prices" (
    "id" "text" NOT NULL,
    "active" boolean,
    "currency" "text",
    "description" "text",
    "interval" "public"."pricing_plan_interval",
    "interval_count" integer,
    "metadata" "jsonb",
    "product_id" "text",
    "trial_period_days" integer,
    "type" "public"."pricing_type",
    "unit_amount" bigint
);


ALTER TABLE "public"."prices" OWNER TO "postgres";


COMMENT ON TABLE "public"."prices" IS 'Stripe prices; synced via webhook.';



CREATE TABLE IF NOT EXISTS "public"."processed_data" (
    "workflowId" character varying(36) NOT NULL,
    "context" character varying(255) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "value" "text" NOT NULL
);


ALTER TABLE "public"."processed_data" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."product_drafts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "shopify_product_id" bigint,
    "name" "text" NOT NULL,
    "fragrance_oil_id" "text",
    "formula_id" "text",
    "container_id" "text",
    "price" numeric,
    "cost" numeric,
    "status" "text" DEFAULT 'draft'::"text",
    "metadata" "jsonb" DEFAULT '{}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "product_drafts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'pushed'::"text", 'published'::"text", 'archived'::"text"])))
);


ALTER TABLE "public"."product_drafts" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."products" (
    "id" "text" NOT NULL,
    "active" boolean,
    "description" "text",
    "image" "text",
    "metadata" "jsonb",
    "name" "text"
);


ALTER TABLE "public"."products" OWNER TO "postgres";


COMMENT ON TABLE "public"."products" IS 'Stripe products; synced via webhook.';



CREATE TABLE IF NOT EXISTS "public"."profiles" (
    "id" "uuid" NOT NULL,
    "username" "text",
    "full_name" "text",
    "avatar_url" "text",
    "email" "text",
    "website" "text",
    "bio" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "last_sign_in_at" timestamp with time zone,
    "is_onboarded" boolean DEFAULT false,
    "preferences" "jsonb" DEFAULT '{}'::"jsonb",
    "is_admin" boolean DEFAULT false,
    "current_bucket" "text",
    "handle" "text",
    "display_name" "text",
    "role" "text" DEFAULT 'pending'::"text" NOT NULL,
    CONSTRAINT "email_format" CHECK (("email" ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$'::"text")),
    CONSTRAINT "profiles_role_check" CHECK (("role" = ANY (ARRAY['admin'::"text", 'moderator'::"text", 'user'::"text", 'pending'::"text"]))),
    CONSTRAINT "username_length" CHECK (("char_length"("username") >= 3))
);


ALTER TABLE "public"."profiles" OWNER TO "postgres";


COMMENT ON TABLE "public"."profiles" IS 'Public user profiles for the MNKY-VERSE application. Contains user information that can be shared with other users or displayed in the UI.';



COMMENT ON COLUMN "public"."profiles"."is_admin" IS 'Flag indicating whether the user has admin privileges.';



CREATE TABLE IF NOT EXISTS "public"."project" (
    "id" character varying(36) NOT NULL,
    "name" character varying(255) NOT NULL,
    "type" character varying(36) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "icon" "json",
    "description" character varying(512),
    "creatorId" "uuid"
);


ALTER TABLE "public"."project" OWNER TO "postgres";


COMMENT ON COLUMN "public"."project"."creatorId" IS 'ID of the user who created the project';



CREATE TABLE IF NOT EXISTS "public"."project_relation" (
    "projectId" character varying(36) NOT NULL,
    "userId" "uuid" NOT NULL,
    "role" character varying NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."project_relation" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."role" (
    "slug" character varying(128) NOT NULL,
    "displayName" "text",
    "description" "text",
    "roleType" "text",
    "systemRole" boolean DEFAULT false NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."role" OWNER TO "postgres";


COMMENT ON COLUMN "public"."role"."slug" IS 'Unique identifier of the role for example: "global:owner"';



COMMENT ON COLUMN "public"."role"."displayName" IS 'Name used to display in the UI';



COMMENT ON COLUMN "public"."role"."description" IS 'Text describing the scope in more detail of users';



COMMENT ON COLUMN "public"."role"."roleType" IS 'Type of the role, e.g., global, project, or workflow';



COMMENT ON COLUMN "public"."role"."systemRole" IS 'Indicates if the role is managed by the system and cannot be edited';



CREATE TABLE IF NOT EXISTS "public"."role_scope" (
    "roleSlug" character varying(128) NOT NULL,
    "scopeSlug" character varying(128) NOT NULL
);


ALTER TABLE "public"."role_scope" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."saved_blends" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "product_type" "text" NOT NULL,
    "batch_weight_g" numeric NOT NULL,
    "fragrance_load_pct" numeric NOT NULL,
    "fragrances" "jsonb" DEFAULT '[]'::"jsonb" NOT NULL,
    "notes" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."saved_blends" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."scope" (
    "slug" character varying(128) NOT NULL,
    "displayName" "text",
    "description" "text"
);


ALTER TABLE "public"."scope" OWNER TO "postgres";


COMMENT ON COLUMN "public"."scope"."slug" IS 'Unique identifier of the scope for example: "project:create"';



COMMENT ON COLUMN "public"."scope"."displayName" IS 'Name used to display in the UI';



COMMENT ON COLUMN "public"."scope"."description" IS 'Text describing the scope in more detail of users';



CREATE TABLE IF NOT EXISTS "public"."settings" (
    "key" character varying(255) NOT NULL,
    "value" "text" NOT NULL,
    "loadOnStartup" boolean DEFAULT false NOT NULL
);


ALTER TABLE "public"."settings" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shared_credentials" (
    "credentialsId" character varying(36) NOT NULL,
    "projectId" character varying(36) NOT NULL,
    "role" "text" NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."shared_credentials" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."shared_workflow" (
    "workflowId" character varying(36) NOT NULL,
    "projectId" character varying(36) NOT NULL,
    "role" "text" NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."shared_workflow" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."songs" (
    "id" bigint NOT NULL,
    "author" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "image_path" "text",
    "song_path" "text",
    "title" "text",
    "user_id" "uuid"
);


ALTER TABLE "public"."songs" OWNER TO "postgres";


COMMENT ON TABLE "public"."songs" IS 'User-uploaded songs.';



ALTER TABLE "public"."songs" ALTER COLUMN "id" ADD GENERATED ALWAYS AS IDENTITY (
    SEQUENCE NAME "public"."songs_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."spotify_recommendations" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "fragrance_blend_id" "uuid",
    "fragrance_oil_id" "text",
    "spotify_track_id" "text" NOT NULL,
    "track_name" "text" NOT NULL,
    "track_artist" "text" NOT NULL,
    "track_preview_url" "text",
    "track_external_url" "text",
    "album_image_url" "text",
    "album_name" "text",
    "duration_ms" integer,
    "audio_features" "jsonb",
    "recommendation_reason" "text",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."spotify_recommendations" OWNER TO "postgres";


COMMENT ON TABLE "public"."spotify_recommendations" IS 'Stores Spotify track recommendations linked to fragrance blends and oils';



COMMENT ON COLUMN "public"."spotify_recommendations"."fragrance_blend_id" IS 'UUID of custom fragrance blend (nullable)';



COMMENT ON COLUMN "public"."spotify_recommendations"."fragrance_oil_id" IS 'Notion ID of fragrance oil';



COMMENT ON COLUMN "public"."spotify_recommendations"."audio_features" IS 'JSONB object containing Spotify audio features (energy, valence, tempo, etc.)';



COMMENT ON COLUMN "public"."spotify_recommendations"."recommendation_reason" IS 'Human-readable explanation of why this track was recommended';



CREATE TABLE IF NOT EXISTS "public"."subscriptions" (
    "id" "text" NOT NULL,
    "cancel_at" timestamp with time zone,
    "cancel_at_period_end" boolean,
    "canceled_at" timestamp with time zone,
    "created" timestamp with time zone DEFAULT "now"() NOT NULL,
    "current_period_end" timestamp with time zone NOT NULL,
    "current_period_start" timestamp with time zone NOT NULL,
    "ended_at" timestamp with time zone,
    "metadata" "jsonb",
    "price_id" "text",
    "quantity" integer,
    "status" "public"."subscription_status",
    "trial_end" timestamp with time zone,
    "trial_start" timestamp with time zone,
    "user_id" "uuid" NOT NULL
);


ALTER TABLE "public"."subscriptions" OWNER TO "postgres";


COMMENT ON TABLE "public"."subscriptions" IS 'Stripe subscriptions; synced via webhook.';



CREATE TABLE IF NOT EXISTS "public"."sync_logs" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "source" "text" NOT NULL,
    "entity_type" "text" NOT NULL,
    "records_synced" integer DEFAULT 0,
    "status" "text" DEFAULT 'success'::"text",
    "error_message" "text",
    "synced_at" timestamp with time zone DEFAULT "now"(),
    CONSTRAINT "sync_logs_source_check" CHECK (("source" = ANY (ARRAY['notion'::"text", 'shopify'::"text"]))),
    CONSTRAINT "sync_logs_status_check" CHECK (("status" = ANY (ARRAY['success'::"text", 'partial'::"text", 'error'::"text"])))
);


ALTER TABLE "public"."sync_logs" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tag_entity" (
    "name" character varying(24) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "id" character varying(36) NOT NULL
);


ALTER TABLE "public"."tag_entity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."test_case_execution" (
    "id" character varying(36) NOT NULL,
    "testRunId" character varying(36) NOT NULL,
    "executionId" integer,
    "status" character varying NOT NULL,
    "runAt" timestamp(3) with time zone,
    "completedAt" timestamp(3) with time zone,
    "errorCode" character varying,
    "errorDetails" "json",
    "metrics" "json",
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "inputs" "json",
    "outputs" "json"
);


ALTER TABLE "public"."test_case_execution" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."test_run" (
    "id" character varying(36) NOT NULL,
    "workflowId" character varying(36) NOT NULL,
    "status" character varying NOT NULL,
    "errorCode" character varying,
    "errorDetails" "json",
    "runAt" timestamp(3) with time zone,
    "completedAt" timestamp(3) with time zone,
    "metrics" "json",
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."test_run" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."tool" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "name" character varying NOT NULL,
    "description" "text" NOT NULL,
    "color" character varying NOT NULL,
    "iconSrc" character varying,
    "schema" "text",
    "func" "text",
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."tool" OWNER TO "postgres";


COMMENT ON TABLE "public"."tool" IS 'Table for tool';



CREATE TABLE IF NOT EXISTS "public"."track_artists" (
    "track_id" "uuid" NOT NULL,
    "artist_id" "uuid" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."track_artists" OWNER TO "postgres";


COMMENT ON TABLE "public"."track_artists" IS 'Junction: which artists are on which track.';



CREATE TABLE IF NOT EXISTS "public"."tracks" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "title" "text" NOT NULL,
    "image_url" "text",
    "album" "text",
    "duration_text" "text",
    "artist_names" "text"[] DEFAULT '{}'::"text"[],
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL,
    "album_id" "uuid",
    "navidrome_track_id" "text",
    "navidrome_cover_art_id" "text"
);


ALTER TABLE "public"."tracks" OWNER TO "postgres";


COMMENT ON TABLE "public"."tracks" IS 'Track metadata for display; streaming URLs from Navidrome or storage.';



COMMENT ON COLUMN "public"."tracks"."navidrome_track_id" IS 'Navidrome song id; used to skip already-synced and avoid duplicates.';



COMMENT ON COLUMN "public"."tracks"."navidrome_cover_art_id" IS 'Navidrome coverArt id for cover art API.';



CREATE TABLE IF NOT EXISTS "public"."upsert_history" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "chatflowid" character varying NOT NULL,
    "result" "text" NOT NULL,
    "flowData" "text" NOT NULL,
    "date" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."upsert_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "email" character varying(255),
    "firstName" character varying(32),
    "lastName" character varying(32),
    "password" character varying(255),
    "personalizationAnswers" "json",
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "settings" "json",
    "disabled" boolean DEFAULT false NOT NULL,
    "mfaEnabled" boolean DEFAULT false NOT NULL,
    "mfaSecret" "text",
    "mfaRecoveryCodes" "text",
    "lastActiveAt" "date",
    "roleSlug" character varying(128) DEFAULT 'global:member'::character varying NOT NULL
);


ALTER TABLE "public"."user" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_api_keys" (
    "id" character varying(36) NOT NULL,
    "userId" "uuid" NOT NULL,
    "label" character varying(100) NOT NULL,
    "apiKey" character varying NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "scopes" "json",
    "audience" character varying DEFAULT 'public-api'::character varying NOT NULL
);


ALTER TABLE "public"."user_api_keys" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."user_settings" (
    "user_id" "uuid" NOT NULL,
    "theme" "text" DEFAULT 'light'::"text",
    "notification_preferences" "jsonb" DEFAULT '{"push": true, "email": true, "chat_updates": true}'::"jsonb",
    "ai_preferences" "jsonb" DEFAULT '{"auto_save": true, "preferred_agent": null, "conversation_history": true}'::"jsonb",
    "privacy_settings" "jsonb" DEFAULT '{"share_usage_data": true, "allow_recommendations": true}'::"jsonb",
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_settings" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_settings" IS 'User preferences and settings for the MNKY-VERSE application.';



CREATE TABLE IF NOT EXISTS "public"."user_spotify_tokens" (
    "user_id" "uuid" NOT NULL,
    "access_token" "text" NOT NULL,
    "refresh_token" "text" NOT NULL,
    "expires_at" timestamp with time zone,
    "updated_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."user_spotify_tokens" OWNER TO "postgres";


COMMENT ON TABLE "public"."user_spotify_tokens" IS 'Spotify OAuth tokens; persisted so API routes work after Supabase session refresh.';



CREATE TABLE IF NOT EXISTS "public"."users" (
    "id" "uuid" NOT NULL,
    "avatar_url" "text",
    "billing_address" "jsonb",
    "full_name" "text",
    "payment_method" "jsonb",
    "role" "text" DEFAULT 'user'::"text" NOT NULL,
    "beta_until" timestamp with time zone,
    CONSTRAINT "users_role_check" CHECK (("role" = ANY (ARRAY['admin'::"text", 'beta'::"text", 'user'::"text"])))
);


ALTER TABLE "public"."users" OWNER TO "postgres";


COMMENT ON TABLE "public"."users" IS 'App user profiles and billing; id matches auth.users.';



COMMENT ON COLUMN "public"."users"."role" IS 'Access role: admin (full), beta (PIN), user (subscription required).';



COMMENT ON COLUMN "public"."users"."beta_until" IS 'When beta access expires; null = no expiry or not beta.';



CREATE TABLE IF NOT EXISTS "public"."variable" (
    "id" "uuid" DEFAULT "public"."uuid_generate_v4"() NOT NULL,
    "name" character varying NOT NULL,
    "value" "text" NOT NULL,
    "type" "text",
    "createdDate" timestamp without time zone DEFAULT "now"() NOT NULL,
    "updatedDate" timestamp without time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."variable" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."variables" (
    "key" character varying(50) NOT NULL,
    "type" character varying(50) DEFAULT 'string'::character varying NOT NULL,
    "value" character varying(255),
    "id" character varying(36) NOT NULL,
    "projectId" character varying(36)
);


ALTER TABLE "public"."variables" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."verse_blog_posts" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "notion_id" "text" NOT NULL,
    "title" "text" NOT NULL,
    "slug" "text" NOT NULL,
    "excerpt" "text" DEFAULT ''::"text" NOT NULL,
    "content" "text" DEFAULT ''::"text" NOT NULL,
    "status" "text" DEFAULT 'draft'::"text" NOT NULL,
    "published_at" timestamp with time zone,
    "cover_url" "text",
    "sort_order" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"(),
    "updated_at" timestamp with time zone DEFAULT "now"(),
    "author_agent" "text",
    CONSTRAINT "verse_blog_posts_status_check" CHECK (("status" = ANY (ARRAY['draft'::"text", 'published'::"text"])))
);


ALTER TABLE "public"."verse_blog_posts" OWNER TO "postgres";


COMMENT ON TABLE "public"."verse_blog_posts" IS 'MNKY VERSE Blog posts synced from Notion; written by sync API (service role).';



COMMENT ON COLUMN "public"."verse_blog_posts"."author_agent" IS 'Agent identifier: mood_mnky, sage_mnky, code_mnky (from Notion Author/Agent select).';



CREATE TABLE IF NOT EXISTS "public"."verse_music_playlist" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "media_asset_id" "uuid" NOT NULL,
    "sort_order" integer DEFAULT 0 NOT NULL,
    "created_at" timestamp with time zone DEFAULT "now"() NOT NULL
);


ALTER TABLE "public"."verse_music_playlist" OWNER TO "postgres";


COMMENT ON TABLE "public"."verse_music_playlist" IS 'Admin-curated playlist for Verse music player; public read, admin write.';



CREATE TABLE IF NOT EXISTS "public"."voice_consents" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "openai_consent_id" "text" NOT NULL,
    "name" "text",
    "language" "text",
    "created_at" timestamp with time zone DEFAULT "now"()
);


ALTER TABLE "public"."voice_consents" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."webhook_entity" (
    "webhookPath" character varying NOT NULL,
    "method" character varying NOT NULL,
    "node" character varying NOT NULL,
    "webhookId" character varying,
    "pathLength" integer,
    "workflowId" character varying(36) NOT NULL
);


ALTER TABLE "public"."webhook_entity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."workflow_dependency" (
    "id" integer NOT NULL,
    "workflowId" character varying(36) NOT NULL,
    "workflowVersionId" integer NOT NULL,
    "dependencyType" character varying(32) NOT NULL,
    "dependencyKey" character varying(255) NOT NULL,
    "dependencyInfo" "json",
    "indexVersionId" smallint DEFAULT 1 NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL
);


ALTER TABLE "public"."workflow_dependency" OWNER TO "postgres";


COMMENT ON COLUMN "public"."workflow_dependency"."workflowVersionId" IS 'Version of the workflow';



COMMENT ON COLUMN "public"."workflow_dependency"."dependencyType" IS 'Type of dependency: "credential", "nodeType", "webhookPath", or "workflowCall"';



COMMENT ON COLUMN "public"."workflow_dependency"."dependencyKey" IS 'ID or name of the dependency';



COMMENT ON COLUMN "public"."workflow_dependency"."dependencyInfo" IS 'Additional info about the dependency, interpreted based on type';



COMMENT ON COLUMN "public"."workflow_dependency"."indexVersionId" IS 'Version of the index structure';



ALTER TABLE "public"."workflow_dependency" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."workflow_dependency_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."workflow_entity" (
    "name" character varying(128) NOT NULL,
    "active" boolean NOT NULL,
    "nodes" "json" NOT NULL,
    "connections" "json" NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "settings" "json",
    "staticData" "json",
    "pinData" "json",
    "versionId" character(36) NOT NULL,
    "triggerCount" integer DEFAULT 0 NOT NULL,
    "id" character varying(36) NOT NULL,
    "meta" "json",
    "parentFolderId" character varying(36) DEFAULT NULL::character varying,
    "isArchived" boolean DEFAULT false NOT NULL,
    "versionCounter" integer DEFAULT 1 NOT NULL,
    "description" "text",
    "activeVersionId" character varying(36)
);


ALTER TABLE "public"."workflow_entity" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."workflow_history" (
    "versionId" character varying(36) NOT NULL,
    "workflowId" character varying(36) NOT NULL,
    "authors" character varying(255) NOT NULL,
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "updatedAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    "nodes" "json" NOT NULL,
    "connections" "json" NOT NULL,
    "name" character varying(128),
    "autosaved" boolean DEFAULT false NOT NULL,
    "description" "text"
);


ALTER TABLE "public"."workflow_history" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."workflow_publish_history" (
    "id" integer NOT NULL,
    "workflowId" character varying(36) NOT NULL,
    "versionId" character varying(36) NOT NULL,
    "event" character varying(36) NOT NULL,
    "userId" "uuid",
    "createdAt" timestamp(3) with time zone DEFAULT CURRENT_TIMESTAMP(3) NOT NULL,
    CONSTRAINT "CHK_workflow_publish_history_event" CHECK ((("event")::"text" = ANY ((ARRAY['activated'::character varying, 'deactivated'::character varying])::"text"[])))
);


ALTER TABLE "public"."workflow_publish_history" OWNER TO "postgres";


COMMENT ON COLUMN "public"."workflow_publish_history"."event" IS 'Type of history record: activated (workflow is now active), deactivated (workflow is now inactive)';



ALTER TABLE "public"."workflow_publish_history" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."workflow_publish_history_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);



CREATE TABLE IF NOT EXISTS "public"."workflow_statistics" (
    "count" bigint DEFAULT 0,
    "latestEvent" timestamp(3) with time zone,
    "name" character varying(128) NOT NULL,
    "workflowId" character varying(36) NOT NULL,
    "rootCount" bigint DEFAULT 0,
    "id" integer NOT NULL,
    "workflowName" character varying(128)
);


ALTER TABLE "public"."workflow_statistics" OWNER TO "postgres";


CREATE SEQUENCE IF NOT EXISTS "public"."workflow_statistics_id_seq"
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE "public"."workflow_statistics_id_seq" OWNER TO "postgres";


ALTER SEQUENCE "public"."workflow_statistics_id_seq" OWNED BY "public"."workflow_statistics"."id";



CREATE TABLE IF NOT EXISTS "public"."workflows_tags" (
    "workflowId" character varying(36) NOT NULL,
    "tagId" character varying(36) NOT NULL
);


ALTER TABLE "public"."workflows_tags" OWNER TO "postgres";


ALTER TABLE ONLY "public"."auth_provider_sync_history" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."auth_provider_sync_history_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."execution_annotations" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."execution_annotations_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."execution_entity" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."execution_entity_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."execution_metadata" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."execution_metadata_temp_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."migrations" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."migrations_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."workflow_statistics" ALTER COLUMN "id" SET DEFAULT "nextval"('"public"."workflow_statistics_id_seq"'::"regclass");



ALTER TABLE ONLY "public"."test_run"
    ADD CONSTRAINT "PK_011c050f566e9db509a0fadb9b9" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."installed_packages"
    ADD CONSTRAINT "PK_08cc9197c39b028c1e9beca225940576fd1a5804" PRIMARY KEY ("packageName");



ALTER TABLE ONLY "public"."execution_metadata"
    ADD CONSTRAINT "PK_17a0b6284f8d626aae88e1c16e4" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project_relation"
    ADD CONSTRAINT "PK_1caaa312a5d7184a003be0f0cb6" PRIMARY KEY ("projectId", "userId");



ALTER TABLE ONLY "public"."chat_hub_sessions"
    ADD CONSTRAINT "PK_1eafef1273c70e4464fec703412" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."folder_tag"
    ADD CONSTRAINT "PK_27e4e00852f6b06a925a4d83a3e" PRIMARY KEY ("folderId", "tagId");



ALTER TABLE ONLY "public"."role"
    ADD CONSTRAINT "PK_35c9b140caaf6da09cfabb0d675" PRIMARY KEY ("slug");



ALTER TABLE ONLY "public"."upsert_history"
    ADD CONSTRAINT "PK_37327b22b6e246319bd5eeb0e88" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."credential"
    ADD CONSTRAINT "PK_3a5169bcd3d5463cefeec78be82" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tool"
    ADD CONSTRAINT "PK_3bf5b1016a384916073184f99b7" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."assistant"
    ADD CONSTRAINT "PK_3c7cea7a044ac4c92764576cdbf" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_flow"
    ADD CONSTRAINT "PK_3c7cea7d047ac4b91764574cdbf" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."custom_template"
    ADD CONSTRAINT "PK_3c7cea7d087ac4b91764574cdbf" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_message"
    ADD CONSTRAINT "PK_3cc0d85193aade457d3077dd06b" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."project"
    ADD CONSTRAINT "PK_4d68b1358bb5b766d3e78f32f57" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflow_dependency"
    ADD CONSTRAINT "PK_52325e34cd7a2f0f67b0f3cad65" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."invalid_auth_token"
    ADD CONSTRAINT "PK_5779069b7235b256d91f7af1a15" PRIMARY KEY ("token");



ALTER TABLE ONLY "public"."shared_workflow"
    ADD CONSTRAINT "PK_5ba87620386b847201c9531c58f" PRIMARY KEY ("workflowId", "projectId");



ALTER TABLE ONLY "public"."folder"
    ADD CONSTRAINT "PK_6278a41a706740c94c02e288df8" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."data_table_column"
    ADD CONSTRAINT "PK_673cb121ee4a8a5e27850c72c51" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."annotation_tag_entity"
    ADD CONSTRAINT "PK_69dfa041592c30bbc0d4b84aa00" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."oauth_refresh_tokens"
    ADD CONSTRAINT "PK_74abaed0b30711b6532598b0392" PRIMARY KEY ("token");



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "PK_7704a5add6baed43eef835f0bfb" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."execution_annotations"
    ADD CONSTRAINT "PK_7afcf93ffa20c4252869a7c6a23" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."dynamic_credential_entry"
    ADD CONSTRAINT "PK_7bc73da3b8be7591696e14809d5" PRIMARY KEY ("credential_id", "subject_id", "resolver_id");



ALTER TABLE ONLY "public"."oauth_user_consents"
    ADD CONSTRAINT "PK_85b9ada746802c8993103470f05" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."migrations"
    ADD CONSTRAINT "PK_8c82d7f526340ab734260ea46be" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."installed_nodes"
    ADD CONSTRAINT "PK_8ebd28194e4f792f96b5933423fc439df97d9689" PRIMARY KEY ("name");



ALTER TABLE ONLY "public"."shared_credentials"
    ADD CONSTRAINT "PK_8ef3a59796a228913f251779cff" PRIMARY KEY ("credentialsId", "projectId");



ALTER TABLE ONLY "public"."document_store_file_chunk"
    ADD CONSTRAINT "PK_90005043dd774f54-9830ab78f9" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."test_case_execution"
    ADD CONSTRAINT "PK_90c121f77a78a6580e94b794bce" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."apikey"
    ADD CONSTRAINT "PK_96109043dd704f53-9830ab78f0" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_api_keys"
    ADD CONSTRAINT "PK_978fa5caa3468f463dac9d92e69" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."execution_annotation_tags"
    ADD CONSTRAINT "PK_979ec03d31294cca484be65d11f" PRIMARY KEY ("annotationId", "tagId");



ALTER TABLE ONLY "public"."lead"
    ADD CONSTRAINT "PK_98419043dd704f54-9830ab78f0" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."variable"
    ADD CONSTRAINT "PK_98419043dd704f54-9830ab78f8" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_message_feedback"
    ADD CONSTRAINT "PK_98419043dd704f54-9830ab78f9" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."document_store"
    ADD CONSTRAINT "PK_98495043dd774f54-9830ab78f9" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."webhook_entity"
    ADD CONSTRAINT "PK_b21ace2e13596ccd87dc9bf4ea6" PRIMARY KEY ("webhookPath", "method");



ALTER TABLE ONLY "public"."insights_by_period"
    ADD CONSTRAINT "PK_b606942249b90cc39b0265f0575" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflow_history"
    ADD CONSTRAINT "PK_b6572dd6173e4cd06fe79937b58" PRIMARY KEY ("versionId");



ALTER TABLE ONLY "public"."dynamic_credential_resolver"
    ADD CONSTRAINT "PK_b76cfb088dcdaf5275e9980bb64" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."scope"
    ADD CONSTRAINT "PK_bfc45df0481abd7f355d6187da1" PRIMARY KEY ("slug");



ALTER TABLE ONLY "public"."oauth_clients"
    ADD CONSTRAINT "PK_c4759172d3431bae6f04e678e0d" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflow_publish_history"
    ADD CONSTRAINT "PK_c788f7caf88e91e365c97d6d04a" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."processed_data"
    ADD CONSTRAINT "PK_ca04b9d8dc72de268fe07a65773" PRIMARY KEY ("workflowId", "context");



ALTER TABLE ONLY "public"."settings"
    ADD CONSTRAINT "PK_dc0fe14e6d9943f268e7b119f69ab8bd" PRIMARY KEY ("key");



ALTER TABLE ONLY "public"."oauth_access_tokens"
    ADD CONSTRAINT "PK_dcd71f96a5d5f4bf79e67d322bf" PRIMARY KEY ("token");



ALTER TABLE ONLY "public"."data_table"
    ADD CONSTRAINT "PK_e226d0001b9e6097cbfe70617cb" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "PK_ea8f538c94b6e352418254ed6474a81f" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insights_raw"
    ADD CONSTRAINT "PK_ec15125755151e3a7e00e00014f" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_hub_agents"
    ADD CONSTRAINT "PK_f39a3b36bbdf0e2979ddb21cf78" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."insights_metadata"
    ADD CONSTRAINT "PK_f448a94c35218b6208ce20cf5a1" PRIMARY KEY ("metaId");



ALTER TABLE ONLY "public"."oauth_authorization_codes"
    ADD CONSTRAINT "PK_fb91ab932cfbd694061501cc20f" PRIMARY KEY ("code");



ALTER TABLE ONLY "public"."binary_data"
    ADD CONSTRAINT "PK_fc3691585b39408bb0551122af6" PRIMARY KEY ("fileId");



ALTER TABLE ONLY "public"."role_scope"
    ADD CONSTRAINT "PK_role_scope" PRIMARY KEY ("roleSlug", "scopeSlug");



ALTER TABLE ONLY "public"."oauth_user_consents"
    ADD CONSTRAINT "UQ_083721d99ce8db4033e2958ebb4" UNIQUE ("userId", "clientId");



ALTER TABLE ONLY "public"."chat_message_feedback"
    ADD CONSTRAINT "UQ_6352078b5a294f2d22179ea7956" UNIQUE ("messageId");



ALTER TABLE ONLY "public"."data_table_column"
    ADD CONSTRAINT "UQ_8082ec4890f892f0bc77473a123" UNIQUE ("dataTableId", "name");



ALTER TABLE ONLY "public"."data_table"
    ADD CONSTRAINT "UQ_b23096ef747281ac944d28e8b0d" UNIQUE ("projectId", "name");



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "UQ_e12875dfb3b1d92d7d7c5377e2" UNIQUE ("email");



ALTER TABLE ONLY "public"."agent_profiles"
    ADD CONSTRAINT "agent_profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."agent_profiles"
    ADD CONSTRAINT "agent_profiles_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."ai_agents"
    ADD CONSTRAINT "ai_agents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."albums"
    ADD CONSTRAINT "albums_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."analytics"
    ADD CONSTRAINT "analytics_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."artists"
    ADD CONSTRAINT "artists_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."audio_transcripts"
    ADD CONSTRAINT "audio_transcripts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."auth_identity"
    ADD CONSTRAINT "auth_identity_pkey" PRIMARY KEY ("providerId", "providerType");



ALTER TABLE ONLY "public"."auth_provider_sync_history"
    ADD CONSTRAINT "auth_provider_sync_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_messages"
    ADD CONSTRAINT "chat_messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."chat_sessions"
    ADD CONSTRAINT "chat_sessions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."credentials_entity"
    ADD CONSTRAINT "credentials_entity_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."custom_voices"
    ADD CONSTRAINT "custom_voices_openai_voice_id_key" UNIQUE ("openai_voice_id");



ALTER TABLE ONLY "public"."custom_voices"
    ADD CONSTRAINT "custom_voices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."customer_account_code_verifiers"
    ADD CONSTRAINT "customer_account_code_verifiers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."customer_account_code_verifiers"
    ADD CONSTRAINT "customer_account_code_verifiers_state_key" UNIQUE ("state");



ALTER TABLE ONLY "public"."customer_account_tokens"
    ADD CONSTRAINT "customer_account_tokens_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."documents"
    ADD CONSTRAINT "documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."event_destinations"
    ADD CONSTRAINT "event_destinations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."execution_data"
    ADD CONSTRAINT "execution_data_pkey" PRIMARY KEY ("executionId");



ALTER TABLE ONLY "public"."formula_categories"
    ADD CONSTRAINT "formula_categories_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."formula_ingredients"
    ADD CONSTRAINT "formula_ingredients_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."formula_phases"
    ADD CONSTRAINT "formula_phases_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."formulas"
    ADD CONSTRAINT "formulas_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."formulas"
    ADD CONSTRAINT "formulas_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."fragrance_blends"
    ADD CONSTRAINT "fragrance_blends_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fragrance_notes"
    ADD CONSTRAINT "fragrance_notes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fragrance_notes"
    ADD CONSTRAINT "fragrance_notes_slug_key" UNIQUE ("slug");



ALTER TABLE ONLY "public"."fragrance_oils"
    ADD CONSTRAINT "fragrance_oils_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."fragrance_oils"
    ADD CONSTRAINT "fragrance_oils_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."fragrance_reviews"
    ADD CONSTRAINT "fragrance_reviews_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."funnel_answers"
    ADD CONSTRAINT "funnel_answers_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."funnel_definitions"
    ADD CONSTRAINT "funnel_definitions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."funnel_events"
    ADD CONSTRAINT "funnel_events_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."funnel_runs"
    ADD CONSTRAINT "funnel_runs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."liked_navidrome_tracks"
    ADD CONSTRAINT "liked_navidrome_tracks_pkey" PRIMARY KEY ("user_id", "navidrome_track_id");



ALTER TABLE ONLY "public"."liked_songs"
    ADD CONSTRAINT "liked_songs_pkey" PRIMARY KEY ("user_id", "song_id");



ALTER TABLE ONLY "public"."likes"
    ADD CONSTRAINT "likes_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."likes"
    ADD CONSTRAINT "likes_unique_playlist" UNIQUE ("user_id", "playlist_id");



ALTER TABLE ONLY "public"."likes"
    ADD CONSTRAINT "likes_unique_track" UNIQUE ("user_id", "track_id");



ALTER TABLE ONLY "public"."listening_history"
    ADD CONSTRAINT "listening_history_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."media_assets"
    ADD CONSTRAINT "media_assets_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."music_requests"
    ADD CONSTRAINT "music_requests_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."ollama_documents"
    ADD CONSTRAINT "ollama_documents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pending_logins"
    ADD CONSTRAINT "pending_logins_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."pending_logins"
    ADD CONSTRAINT "pending_logins_short_code_key" UNIQUE ("short_code");



ALTER TABLE ONLY "public"."execution_entity"
    ADD CONSTRAINT "pk_e3e63bbf986767844bbe1166d4e" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflows_tags"
    ADD CONSTRAINT "pk_workflows_tags" PRIMARY KEY ("workflowId", "tagId");



ALTER TABLE ONLY "public"."playlist_tracks"
    ADD CONSTRAINT "playlist_tracks_pkey" PRIMARY KEY ("playlist_id", "track_id");



ALTER TABLE ONLY "public"."playlists"
    ADD CONSTRAINT "playlists_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."prices"
    ADD CONSTRAINT "prices_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."product_drafts"
    ADD CONSTRAINT "product_drafts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."products"
    ADD CONSTRAINT "products_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_email_key" UNIQUE ("email");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_username_key" UNIQUE ("username");



ALTER TABLE ONLY "public"."saved_blends"
    ADD CONSTRAINT "saved_blends_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."songs"
    ADD CONSTRAINT "songs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."spotify_recommendations"
    ADD CONSTRAINT "spotify_recommendations_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."sync_logs"
    ADD CONSTRAINT "sync_logs_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."tag_entity"
    ADD CONSTRAINT "tag_entity_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."track_artists"
    ADD CONSTRAINT "track_artists_pkey" PRIMARY KEY ("track_id", "artist_id");



ALTER TABLE ONLY "public"."tracks"
    ADD CONSTRAINT "tracks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."user_spotify_tokens"
    ADD CONSTRAINT "user_spotify_tokens_pkey" PRIMARY KEY ("user_id");



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."variables"
    ADD CONSTRAINT "variables_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verse_blog_posts"
    ADD CONSTRAINT "verse_blog_posts_notion_id_key" UNIQUE ("notion_id");



ALTER TABLE ONLY "public"."verse_blog_posts"
    ADD CONSTRAINT "verse_blog_posts_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."verse_music_playlist"
    ADD CONSTRAINT "verse_music_playlist_media_asset_id_key" UNIQUE ("media_asset_id");



ALTER TABLE ONLY "public"."verse_music_playlist"
    ADD CONSTRAINT "verse_music_playlist_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."voice_consents"
    ADD CONSTRAINT "voice_consents_openai_consent_id_key" UNIQUE ("openai_consent_id");



ALTER TABLE ONLY "public"."voice_consents"
    ADD CONSTRAINT "voice_consents_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflow_entity"
    ADD CONSTRAINT "workflow_entity_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."workflow_statistics"
    ADD CONSTRAINT "workflow_statistics_pkey" PRIMARY KEY ("id");



CREATE INDEX "IDX_070b5de842ece9ccdda0d9738b" ON "public"."workflow_publish_history" USING "btree" ("workflowId", "versionId");



CREATE UNIQUE INDEX "IDX_14f68deffaf858465715995508" ON "public"."folder" USING "btree" ("projectId", "id");



CREATE UNIQUE INDEX "IDX_1d8ab99d5861c9388d2dc1cf73" ON "public"."insights_metadata" USING "btree" ("workflowId");



CREATE INDEX "IDX_1e31657f5fe46816c34be7c1b4" ON "public"."workflow_history" USING "btree" ("workflowId");



CREATE UNIQUE INDEX "IDX_1ef35bac35d20bdae979d917a3" ON "public"."user_api_keys" USING "btree" ("apiKey");



CREATE INDEX "IDX_56900edc3cfd16612e2ef2c6a8" ON "public"."binary_data" USING "btree" ("sourceType", "sourceId");



CREATE INDEX "IDX_5f0643f6717905a05164090dde" ON "public"."project_relation" USING "btree" ("userId");



CREATE UNIQUE INDEX "IDX_60b6a84299eeb3f671dfec7693" ON "public"."insights_by_period" USING "btree" ("periodStart", "type", "periodUnit", "metaId");



CREATE INDEX "IDX_61448d56d61802b5dfde5cdb00" ON "public"."project_relation" USING "btree" ("projectId");



CREATE UNIQUE INDEX "IDX_63d7bbae72c767cf162d459fcc" ON "public"."user_api_keys" USING "btree" ("userId", "label");



CREATE INDEX "IDX_8e4b4774db42f1e6dda3452b2a" ON "public"."test_case_execution" USING "btree" ("testRunId");



CREATE UNIQUE INDEX "IDX_97f863fa83c4786f1956508496" ON "public"."execution_annotations" USING "btree" ("executionId");



CREATE INDEX "IDX_99b3e329d13b7bb2fa9b6a43f5" ON "public"."dynamic_credential_entry" USING "btree" ("subject_id");



CREATE INDEX "IDX_9acddcb7a2b51fe37669049fc6" ON "public"."chat_message_feedback" USING "btree" ("chatId");



CREATE INDEX "IDX_9c9ee9df586e60bb723234e499" ON "public"."dynamic_credential_resolver" USING "btree" ("type");



CREATE UNIQUE INDEX "IDX_UniqueRoleDisplayName" ON "public"."role" USING "btree" ("displayName");



CREATE INDEX "IDX_a3697779b366e131b2bbdae297" ON "public"."execution_annotation_tags" USING "btree" ("tagId");



CREATE INDEX "IDX_a4ff2d9b9628ea988fa9e7d0bf" ON "public"."workflow_dependency" USING "btree" ("workflowId");



CREATE UNIQUE INDEX "IDX_ae51b54c4bb430cf92f48b623f" ON "public"."annotation_tag_entity" USING "btree" ("name");



CREATE INDEX "IDX_c1519757391996eb06064f0e7c" ON "public"."execution_annotation_tags" USING "btree" ("annotationId");



CREATE UNIQUE INDEX "IDX_cec8eea3bf49551482ccb4933e" ON "public"."execution_metadata" USING "btree" ("executionId", "key");



CREATE INDEX "IDX_chat_hub_messages_sessionId" ON "public"."chat_hub_messages" USING "btree" ("sessionId");



CREATE INDEX "IDX_chat_hub_sessions_owner_lastmsg_id" ON "public"."chat_hub_sessions" USING "btree" ("ownerId", "lastMessageAt" DESC, "id");



CREATE INDEX "IDX_d57808fe08b77464f6a88a2549" ON "public"."dynamic_credential_entry" USING "btree" ("resolver_id");



CREATE INDEX "IDX_d6870d3b6e4c185d33926f423c" ON "public"."test_run" USING "btree" ("workflowId");



CREATE INDEX "IDX_e213b811b01405a42309a6a410" ON "public"."document_store_file_chunk" USING "btree" ("storeId");



CREATE INDEX "IDX_e48a201071ab85d9d09119d640" ON "public"."workflow_dependency" USING "btree" ("dependencyKey");



CREATE INDEX "IDX_e574527322272fd838f4f0f3d3" ON "public"."chat_message" USING "btree" ("chatflowid");



CREATE INDEX "IDX_e76bae1780b77e56aab1h2asd4" ON "public"."document_store_file_chunk" USING "btree" ("docId");



CREATE INDEX "IDX_e7fe1cfda990c14a445937d0b9" ON "public"."workflow_dependency" USING "btree" ("dependencyType");



CREATE INDEX "IDX_execution_entity_deletedAt" ON "public"."execution_entity" USING "btree" ("deletedAt");



CREATE INDEX "IDX_f56c36fe42894d57e5c664d229" ON "public"."chat_message" USING "btree" ("chatflowid");



CREATE INDEX "IDX_f56c36fe42894d57e5c664d230" ON "public"."chat_message_feedback" USING "btree" ("chatflowid");



CREATE INDEX "IDX_role_scope_scopeSlug" ON "public"."role_scope" USING "btree" ("scopeSlug");



CREATE INDEX "IDX_workflow_entity_name" ON "public"."workflow_entity" USING "btree" ("name");



CREATE UNIQUE INDEX "IDX_workflow_statistics_workflow_name" ON "public"."workflow_statistics" USING "btree" ("workflowId", "name");



CREATE INDEX "_i_d_x_e574527322272fd838f4f0f3d3" ON "public"."chat_message" USING "btree" ("chatflowid");



CREATE INDEX "albums_primary_artist_id_idx" ON "public"."albums" USING "btree" ("primary_artist_id");



CREATE UNIQUE INDEX "artists_name_key" ON "public"."artists" USING "btree" ("name");



CREATE INDEX "chat_messages_session_id_created_at_idx" ON "public"."chat_messages" USING "btree" ("session_id", "created_at");



CREATE INDEX "chat_sessions_user_id_created_at_idx" ON "public"."chat_sessions" USING "btree" ("user_id", "created_at" DESC);



CREATE INDEX "idx_07fde106c0b471d8cc80a64fc8" ON "public"."credentials_entity" USING "btree" ("type");



CREATE INDEX "idx_16f4436789e804e3e1c9eeb240" ON "public"."webhook_entity" USING "btree" ("webhookId", "method", "pathLength");



CREATE UNIQUE INDEX "idx_812eb05f7451ca757fb98444ce" ON "public"."tag_entity" USING "btree" ("name");



CREATE INDEX "idx_audio_transcripts_source" ON "public"."audio_transcripts" USING "btree" ("source_asset_id");



CREATE INDEX "idx_audio_transcripts_user" ON "public"."audio_transcripts" USING "btree" ("user_id");



CREATE INDEX "idx_code_verifiers_created_at" ON "public"."customer_account_code_verifiers" USING "btree" ("created_at");



CREATE INDEX "idx_code_verifiers_state" ON "public"."customer_account_code_verifiers" USING "btree" ("state");



CREATE INDEX "idx_custom_voices_consent" ON "public"."custom_voices" USING "btree" ("consent_id");



CREATE INDEX "idx_custom_voices_openai" ON "public"."custom_voices" USING "btree" ("openai_voice_id");



CREATE INDEX "idx_custom_voices_user" ON "public"."custom_voices" USING "btree" ("user_id");



CREATE INDEX "idx_customer_account_tokens_expires_at" ON "public"."customer_account_tokens" USING "btree" ("expires_at");



CREATE INDEX "idx_customer_account_tokens_shop" ON "public"."customer_account_tokens" USING "btree" ("shop");



CREATE INDEX "idx_execution_entity_stopped_at_status_deleted_at" ON "public"."execution_entity" USING "btree" ("stoppedAt", "status", "deletedAt") WHERE (("stoppedAt" IS NOT NULL) AND ("deletedAt" IS NULL));



CREATE INDEX "idx_execution_entity_wait_till_status_deleted_at" ON "public"."execution_entity" USING "btree" ("waitTill", "status", "deletedAt") WHERE (("waitTill" IS NOT NULL) AND ("deletedAt" IS NULL));



CREATE INDEX "idx_execution_entity_workflow_id_started_at" ON "public"."execution_entity" USING "btree" ("workflowId", "startedAt") WHERE (("startedAt" IS NOT NULL) AND ("deletedAt" IS NULL));



CREATE INDEX "idx_formula_ingredients_phase" ON "public"."formula_ingredients" USING "btree" ("phase_id");



CREATE INDEX "idx_formula_phases_formula" ON "public"."formula_phases" USING "btree" ("formula_id");



CREATE INDEX "idx_formulas_category" ON "public"."formulas" USING "btree" ("category_id");



CREATE UNIQUE INDEX "idx_formulas_slug" ON "public"."formulas" USING "btree" ("slug");



CREATE INDEX "idx_fragrance_blends_fragrance_id" ON "public"."fragrance_blends" USING "btree" ("fragrance_oil_id");



CREATE INDEX "idx_fragrance_notes_name" ON "public"."fragrance_notes" USING "btree" ("name");



CREATE INDEX "idx_fragrance_notes_name_prefix" ON "public"."fragrance_notes" USING "btree" ("lower"("left"("name", 1)));



CREATE UNIQUE INDEX "idx_fragrance_notes_slug" ON "public"."fragrance_notes" USING "btree" ("slug");



CREATE INDEX "idx_fragrance_oils_family" ON "public"."fragrance_oils" USING "btree" ("family");



CREATE INDEX "idx_fragrance_oils_name" ON "public"."fragrance_oils" USING "btree" ("name");



CREATE UNIQUE INDEX "idx_fragrance_oils_notion_id" ON "public"."fragrance_oils" USING "btree" ("notion_id");



CREATE INDEX "idx_fragrance_reviews_fragrance_id" ON "public"."fragrance_reviews" USING "btree" ("fragrance_oil_id");



CREATE INDEX "idx_fragrance_reviews_rating" ON "public"."fragrance_reviews" USING "btree" ("rating");



CREATE INDEX "idx_funnel_answers_run" ON "public"."funnel_answers" USING "btree" ("run_id");



CREATE UNIQUE INDEX "idx_funnel_definitions_provider_form" ON "public"."funnel_definitions" USING "btree" ("provider", "provider_form_id") WHERE ("provider_form_id" IS NOT NULL);



CREATE INDEX "idx_funnel_events_run" ON "public"."funnel_events" USING "btree" ("run_id");



CREATE INDEX "idx_funnel_runs_funnel_user" ON "public"."funnel_runs" USING "btree" ("funnel_id", "user_id");



CREATE UNIQUE INDEX "idx_funnel_runs_provider_submission" ON "public"."funnel_runs" USING "btree" ("provider_submission_id") WHERE ("provider_submission_id" IS NOT NULL);



CREATE INDEX "idx_funnel_runs_user_status" ON "public"."funnel_runs" USING "btree" ("user_id", "status") WHERE ("user_id" IS NOT NULL);



CREATE INDEX "idx_media_assets_bucket" ON "public"."media_assets" USING "btree" ("bucket_id");



CREATE INDEX "idx_media_assets_category" ON "public"."media_assets" USING "btree" ("category") WHERE ("category" IS NOT NULL);



CREATE INDEX "idx_media_assets_linked" ON "public"."media_assets" USING "btree" ("linked_entity_type", "linked_entity_id");



CREATE UNIQUE INDEX "idx_media_assets_path" ON "public"."media_assets" USING "btree" ("bucket_id", "storage_path");



CREATE INDEX "idx_media_assets_shopify" ON "public"."media_assets" USING "btree" ("shopify_product_id", "shopify_image_id") WHERE ("shopify_product_id" IS NOT NULL);



CREATE INDEX "idx_media_assets_tags" ON "public"."media_assets" USING "gin" ("tags");



CREATE INDEX "idx_media_assets_user" ON "public"."media_assets" USING "btree" ("user_id");



CREATE INDEX "idx_pending_logins_expires_at" ON "public"."pending_logins" USING "btree" ("expires_at");



CREATE INDEX "idx_pending_logins_short_code" ON "public"."pending_logins" USING "btree" ("short_code");



CREATE INDEX "idx_profiles_role" ON "public"."profiles" USING "btree" ("role");



CREATE INDEX "idx_spotify_recommendations_fragrance_blend" ON "public"."spotify_recommendations" USING "btree" ("fragrance_blend_id");



CREATE INDEX "idx_spotify_recommendations_fragrance_oil" ON "public"."spotify_recommendations" USING "btree" ("fragrance_oil_id");



CREATE INDEX "idx_spotify_recommendations_track" ON "public"."spotify_recommendations" USING "btree" ("spotify_track_id");



CREATE INDEX "idx_verse_music_playlist_sort" ON "public"."verse_music_playlist" USING "btree" ("sort_order");



CREATE INDEX "idx_voice_consents_openai" ON "public"."voice_consents" USING "btree" ("openai_consent_id");



CREATE INDEX "idx_voice_consents_user" ON "public"."voice_consents" USING "btree" ("user_id");



CREATE INDEX "idx_workflows_tags_workflow_id" ON "public"."workflows_tags" USING "btree" ("workflowId");



CREATE INDEX "likes_user_id_idx" ON "public"."likes" USING "btree" ("user_id");



CREATE INDEX "listening_history_played_at_idx" ON "public"."listening_history" USING "btree" ("played_at" DESC);



CREATE INDEX "listening_history_user_id_idx" ON "public"."listening_history" USING "btree" ("user_id");



CREATE INDEX "music_requests_created_at_idx" ON "public"."music_requests" USING "btree" ("created_at" DESC);



CREATE INDEX "music_requests_user_id_idx" ON "public"."music_requests" USING "btree" ("user_id");



CREATE UNIQUE INDEX "pk_credentials_entity_id" ON "public"."credentials_entity" USING "btree" ("id");



CREATE UNIQUE INDEX "pk_tag_entity_id" ON "public"."tag_entity" USING "btree" ("id");



CREATE UNIQUE INDEX "pk_workflow_entity_id" ON "public"."workflow_entity" USING "btree" ("id");



CREATE INDEX "playlist_tracks_playlist_id_idx" ON "public"."playlist_tracks" USING "btree" ("playlist_id");



CREATE INDEX "playlist_tracks_track_id_idx" ON "public"."playlist_tracks" USING "btree" ("track_id");



CREATE INDEX "playlists_owner_id_idx" ON "public"."playlists" USING "btree" ("owner_id");



CREATE UNIQUE INDEX "profiles_handle_unique" ON "public"."profiles" USING "btree" ("handle") WHERE ("handle" IS NOT NULL);



CREATE INDEX "project_relation_role_idx" ON "public"."project_relation" USING "btree" ("role");



CREATE INDEX "project_relation_role_project_idx" ON "public"."project_relation" USING "btree" ("projectId", "role");



CREATE INDEX "track_artists_artist_id_idx" ON "public"."track_artists" USING "btree" ("artist_id");



CREATE INDEX "track_artists_track_id_idx" ON "public"."track_artists" USING "btree" ("track_id");



CREATE INDEX "tracks_album_id_idx" ON "public"."tracks" USING "btree" ("album_id");



CREATE INDEX "tracks_navidrome_track_id_idx" ON "public"."tracks" USING "btree" ("navidrome_track_id") WHERE ("navidrome_track_id" IS NOT NULL);



CREATE UNIQUE INDEX "tracks_navidrome_track_id_key" ON "public"."tracks" USING "btree" ("navidrome_track_id") WHERE ("navidrome_track_id" IS NOT NULL);



CREATE INDEX "user_role_idx" ON "public"."user" USING "btree" ("roleSlug");



CREATE UNIQUE INDEX "variables_global_key_unique" ON "public"."variables" USING "btree" ("key") WHERE ("projectId" IS NULL);



CREATE UNIQUE INDEX "variables_project_key_unique" ON "public"."variables" USING "btree" ("projectId", "key") WHERE ("projectId" IS NOT NULL);



CREATE INDEX "verse_blog_posts_slug_idx" ON "public"."verse_blog_posts" USING "btree" ("slug");



CREATE INDEX "verse_blog_posts_status_idx" ON "public"."verse_blog_posts" USING "btree" ("status");



CREATE OR REPLACE TRIGGER "agent_profiles_updated_at" BEFORE UPDATE ON "public"."agent_profiles" FOR EACH ROW EXECUTE FUNCTION "public"."set_agent_profiles_updated_at"();



CREATE OR REPLACE TRIGGER "on_profile_created" AFTER INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."handle_new_user_settings"();



CREATE OR REPLACE TRIGGER "on_profile_created_for_bucket" AFTER INSERT ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."create_user_bucket"();



CREATE OR REPLACE TRIGGER "on_profile_updated" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."handle_profile_updated"();



CREATE OR REPLACE TRIGGER "playlists_updated_at" BEFORE UPDATE ON "public"."playlists" FOR EACH ROW EXECUTE FUNCTION "public"."set_updated_at"();



CREATE OR REPLACE TRIGGER "profiles_prevent_non_admin_role_update" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."prevent_non_admin_role_update"();



CREATE OR REPLACE TRIGGER "profiles_sync_is_admin" BEFORE INSERT OR UPDATE OF "role" ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."sync_is_admin_from_role"();



CREATE OR REPLACE TRIGGER "profiles_updated_at" BEFORE UPDATE ON "public"."profiles" FOR EACH ROW EXECUTE FUNCTION "public"."set_profiles_updated_at"();



CREATE OR REPLACE TRIGGER "update_spotify_recommendations_updated_at" BEFORE UPDATE ON "public"."spotify_recommendations" FOR EACH ROW EXECUTE FUNCTION "public"."update_spotify_recommendations_updated_at"();



CREATE OR REPLACE TRIGGER "workflow_version_increment" BEFORE UPDATE ON "public"."workflow_entity" FOR EACH ROW EXECUTE FUNCTION "public"."increment_workflow_version"();



ALTER TABLE ONLY "public"."processed_data"
    ADD CONSTRAINT "FK_06a69a7032c97a763c2c7599464" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_entity"
    ADD CONSTRAINT "FK_08d6c67b7f722b0039d9d5ed620" FOREIGN KEY ("activeVersionId") REFERENCES "public"."workflow_history"("versionId") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."insights_metadata"
    ADD CONSTRAINT "FK_1d8ab99d5861c9388d2dc1cf733" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."workflow_history"
    ADD CONSTRAINT "FK_1e31657f5fe46816c34be7c1b4b" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_1f4998c8a7dec9e00a9ab15550e" FOREIGN KEY ("revisionOfMessageId") REFERENCES "public"."chat_hub_messages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oauth_user_consents"
    ADD CONSTRAINT "FK_21e6c3c2d78a097478fae6aaefa" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."insights_metadata"
    ADD CONSTRAINT "FK_2375a1eda085adb16b24615b69c" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_25c9736e7f769f3a005eef4b372" FOREIGN KEY ("retryOfMessageId") REFERENCES "public"."chat_hub_messages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."execution_metadata"
    ADD CONSTRAINT "FK_31d0b4c93fb85ced26f6005cda3" FOREIGN KEY ("executionId") REFERENCES "public"."execution_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shared_credentials"
    ADD CONSTRAINT "FK_416f66fc846c7c442970c094ccf" FOREIGN KEY ("credentialsId") REFERENCES "public"."credentials_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."variables"
    ADD CONSTRAINT "FK_42f6c766f9f9d2edcc15bdd6e9b" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_agents"
    ADD CONSTRAINT "FK_441ba2caba11e077ce3fbfa2cd8" FOREIGN KEY ("ownerId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_relation"
    ADD CONSTRAINT "FK_5f0643f6717905a05164090dde7" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_relation"
    ADD CONSTRAINT "FK_61448d56d61802b5dfde5cdb002" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."insights_by_period"
    ADD CONSTRAINT "FK_6414cfed98daabbfdd61a1cfbc0" FOREIGN KEY ("metaId") REFERENCES "public"."insights_metadata"("metaId") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oauth_authorization_codes"
    ADD CONSTRAINT "FK_64d965bd072ea24fb6da55468cd" FOREIGN KEY ("clientId") REFERENCES "public"."oauth_clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_6afb260449dd7a9b85355d4e0c9" FOREIGN KEY ("executionId") REFERENCES "public"."execution_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."insights_raw"
    ADD CONSTRAINT "FK_6e2e33741adef2a7c5d66befa4e" FOREIGN KEY ("metaId") REFERENCES "public"."insights_metadata"("metaId") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_publish_history"
    ADD CONSTRAINT "FK_6eab5bd9eedabe9c54bd879fc40" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."oauth_access_tokens"
    ADD CONSTRAINT "FK_7234a36d8e49a1fa85095328845" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."installed_nodes"
    ADD CONSTRAINT "FK_73f857fc5dce682cef8a99c11dbddbc969618951" FOREIGN KEY ("package") REFERENCES "public"."installed_packages"("packageName") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oauth_access_tokens"
    ADD CONSTRAINT "FK_78b26968132b7e5e45b75876481" FOREIGN KEY ("clientId") REFERENCES "public"."oauth_clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_sessions"
    ADD CONSTRAINT "FK_7bc13b4c7e6afbfaf9be326c189" FOREIGN KEY ("credentialId") REFERENCES "public"."credentials_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."folder"
    ADD CONSTRAINT "FK_804ea52f6729e3940498bd54d78" FOREIGN KEY ("parentFolderId") REFERENCES "public"."folder"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shared_credentials"
    ADD CONSTRAINT "FK_812c2852270da1247756e77f5a4" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."test_case_execution"
    ADD CONSTRAINT "FK_8e4b4774db42f1e6dda3452b2af" FOREIGN KEY ("testRunId") REFERENCES "public"."test_run"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."data_table_column"
    ADD CONSTRAINT "FK_930b6e8faaf88294cef23484160" FOREIGN KEY ("dataTableId") REFERENCES "public"."data_table"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."folder_tag"
    ADD CONSTRAINT "FK_94a60854e06f2897b2e0d39edba" FOREIGN KEY ("folderId") REFERENCES "public"."folder"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."execution_annotations"
    ADD CONSTRAINT "FK_97f863fa83c4786f19565084960" FOREIGN KEY ("executionId") REFERENCES "public"."execution_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_agents"
    ADD CONSTRAINT "FK_9c61ad497dcbae499c96a6a78ba" FOREIGN KEY ("credentialId") REFERENCES "public"."credentials_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."chat_hub_sessions"
    ADD CONSTRAINT "FK_9f9293d9f552496c40e0d1a8f80" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."execution_annotation_tags"
    ADD CONSTRAINT "FK_a3697779b366e131b2bbdae2976" FOREIGN KEY ("tagId") REFERENCES "public"."annotation_tag_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shared_workflow"
    ADD CONSTRAINT "FK_a45ea5f27bcfdc21af9b4188560" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_dependency"
    ADD CONSTRAINT "FK_a4ff2d9b9628ea988fa9e7d0bf8" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oauth_user_consents"
    ADD CONSTRAINT "FK_a651acea2f6c97f8c4514935486" FOREIGN KEY ("clientId") REFERENCES "public"."oauth_clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oauth_refresh_tokens"
    ADD CONSTRAINT "FK_a699f3ed9fd0c1b19bc2608ac53" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."folder"
    ADD CONSTRAINT "FK_a8260b0b36939c6247f385b8221" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."oauth_authorization_codes"
    ADD CONSTRAINT "FK_aa8d3560484944c19bdf79ffa16" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_acf8926098f063cdbbad8497fd1" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."oauth_refresh_tokens"
    ADD CONSTRAINT "FK_b388696ce4d8be7ffbe8d3e4b69" FOREIGN KEY ("clientId") REFERENCES "public"."oauth_clients"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_publish_history"
    ADD CONSTRAINT "FK_b4cfbc7556d07f36ca177f5e473" FOREIGN KEY ("versionId") REFERENCES "public"."workflow_history"("versionId") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_publish_history"
    ADD CONSTRAINT "FK_c01316f8c2d7101ec4fa9809267" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."execution_annotation_tags"
    ADD CONSTRAINT "FK_c1519757391996eb06064f0e7c8" FOREIGN KEY ("annotationId") REFERENCES "public"."execution_annotations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."data_table"
    ADD CONSTRAINT "FK_c2a794257dee48af7c9abf681de" FOREIGN KEY ("projectId") REFERENCES "public"."project"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project_relation"
    ADD CONSTRAINT "FK_c6b99592dc96b0d836d7a21db91" FOREIGN KEY ("role") REFERENCES "public"."role"("slug");



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_chat_hub_messages_agentId" FOREIGN KEY ("agentId") REFERENCES "public"."chat_hub_agents"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."chat_hub_sessions"
    ADD CONSTRAINT "FK_chat_hub_sessions_agentId" FOREIGN KEY ("agentId") REFERENCES "public"."chat_hub_agents"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."dynamic_credential_entry"
    ADD CONSTRAINT "FK_d57808fe08b77464f6a88a25494" FOREIGN KEY ("resolver_id") REFERENCES "public"."dynamic_credential_resolver"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."test_run"
    ADD CONSTRAINT "FK_d6870d3b6e4c185d33926f423c8" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."shared_workflow"
    ADD CONSTRAINT "FK_daa206a04983d47d0a9c34649ce" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."folder_tag"
    ADD CONSTRAINT "FK_dc88164176283de80af47621746" FOREIGN KEY ("tagId") REFERENCES "public"."tag_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_api_keys"
    ADD CONSTRAINT "FK_e131705cbbc8fb589889b02d457" FOREIGN KEY ("userId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_e22538eb50a71a17954cd7e076c" FOREIGN KEY ("sessionId") REFERENCES "public"."chat_hub_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."test_case_execution"
    ADD CONSTRAINT "FK_e48965fac35d0f5b9e7f51d8c44" FOREIGN KEY ("executionId") REFERENCES "public"."execution_entity"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."chat_hub_messages"
    ADD CONSTRAINT "FK_e5d1fa722c5a8d38ac204746662" FOREIGN KEY ("previousMessageId") REFERENCES "public"."chat_hub_messages"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."dynamic_credential_entry"
    ADD CONSTRAINT "FK_e97db563e505ae5f57ca33ef221" FOREIGN KEY ("credential_id") REFERENCES "public"."credentials_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_hub_sessions"
    ADD CONSTRAINT "FK_e9ecf8ede7d989fcd18790fe36a" FOREIGN KEY ("ownerId") REFERENCES "public"."user"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user"
    ADD CONSTRAINT "FK_eaea92ee7bfb9c1b6cd01505d56" FOREIGN KEY ("roleSlug") REFERENCES "public"."role"("slug");



ALTER TABLE ONLY "public"."role_scope"
    ADD CONSTRAINT "FK_role" FOREIGN KEY ("roleSlug") REFERENCES "public"."role"("slug") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."role_scope"
    ADD CONSTRAINT "FK_scope" FOREIGN KEY ("scopeSlug") REFERENCES "public"."scope"("slug") ON UPDATE CASCADE ON DELETE CASCADE;



ALTER TABLE ONLY "public"."albums"
    ADD CONSTRAINT "albums_primary_artist_id_fkey" FOREIGN KEY ("primary_artist_id") REFERENCES "public"."artists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."analytics"
    ADD CONSTRAINT "analytics_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."audio_transcripts"
    ADD CONSTRAINT "audio_transcripts_source_asset_id_fkey" FOREIGN KEY ("source_asset_id") REFERENCES "public"."media_assets"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."audio_transcripts"
    ADD CONSTRAINT "audio_transcripts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."auth_identity"
    ADD CONSTRAINT "auth_identity_userId_fkey" FOREIGN KEY ("userId") REFERENCES "public"."user"("id");



ALTER TABLE ONLY "public"."chat_messages"
    ADD CONSTRAINT "chat_messages_session_id_fkey" FOREIGN KEY ("session_id") REFERENCES "public"."chat_sessions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."chat_sessions"
    ADD CONSTRAINT "chat_sessions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_agent_id_fkey" FOREIGN KEY ("agent_id") REFERENCES "public"."ai_agents"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."conversations"
    ADD CONSTRAINT "conversations_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."credentials_entity"
    ADD CONSTRAINT "credentials_entity_resolverId_foreign" FOREIGN KEY ("resolverId") REFERENCES "public"."dynamic_credential_resolver"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."custom_voices"
    ADD CONSTRAINT "custom_voices_consent_id_fkey" FOREIGN KEY ("consent_id") REFERENCES "public"."voice_consents"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."custom_voices"
    ADD CONSTRAINT "custom_voices_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."customers"
    ADD CONSTRAINT "customers_id_fkey" FOREIGN KEY ("id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."execution_data"
    ADD CONSTRAINT "execution_data_fk" FOREIGN KEY ("executionId") REFERENCES "public"."execution_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."execution_entity"
    ADD CONSTRAINT "fk_execution_entity_workflow_id" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."webhook_entity"
    ADD CONSTRAINT "fk_webhook_entity_workflow_id" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflow_entity"
    ADD CONSTRAINT "fk_workflow_parent_folder" FOREIGN KEY ("parentFolderId") REFERENCES "public"."folder"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflows_tags"
    ADD CONSTRAINT "fk_workflows_tags_tag_id" FOREIGN KEY ("tagId") REFERENCES "public"."tag_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."workflows_tags"
    ADD CONSTRAINT "fk_workflows_tags_workflow_id" FOREIGN KEY ("workflowId") REFERENCES "public"."workflow_entity"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."formula_ingredients"
    ADD CONSTRAINT "formula_ingredients_phase_id_fkey" FOREIGN KEY ("phase_id") REFERENCES "public"."formula_phases"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."formula_phases"
    ADD CONSTRAINT "formula_phases_formula_id_fkey" FOREIGN KEY ("formula_id") REFERENCES "public"."formulas"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."formulas"
    ADD CONSTRAINT "formulas_category_id_fkey" FOREIGN KEY ("category_id") REFERENCES "public"."formula_categories"("id") ON DELETE RESTRICT;



ALTER TABLE ONLY "public"."funnel_answers"
    ADD CONSTRAINT "funnel_answers_run_id_fkey" FOREIGN KEY ("run_id") REFERENCES "public"."funnel_runs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."funnel_definitions"
    ADD CONSTRAINT "funnel_definitions_created_by_fkey" FOREIGN KEY ("created_by") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."funnel_events"
    ADD CONSTRAINT "funnel_events_run_id_fkey" FOREIGN KEY ("run_id") REFERENCES "public"."funnel_runs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."funnel_runs"
    ADD CONSTRAINT "funnel_runs_funnel_id_fkey" FOREIGN KEY ("funnel_id") REFERENCES "public"."funnel_definitions"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."funnel_runs"
    ADD CONSTRAINT "funnel_runs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."liked_navidrome_tracks"
    ADD CONSTRAINT "liked_navidrome_tracks_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."liked_songs"
    ADD CONSTRAINT "liked_songs_song_id_fkey" FOREIGN KEY ("song_id") REFERENCES "public"."songs"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."liked_songs"
    ADD CONSTRAINT "liked_songs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."likes"
    ADD CONSTRAINT "likes_playlist_id_fkey" FOREIGN KEY ("playlist_id") REFERENCES "public"."playlists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."likes"
    ADD CONSTRAINT "likes_track_id_fkey" FOREIGN KEY ("track_id") REFERENCES "public"."tracks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."likes"
    ADD CONSTRAINT "likes_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."listening_history"
    ADD CONSTRAINT "listening_history_track_id_fkey" FOREIGN KEY ("track_id") REFERENCES "public"."tracks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."listening_history"
    ADD CONSTRAINT "listening_history_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."media_assets"
    ADD CONSTRAINT "media_assets_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."messages"
    ADD CONSTRAINT "messages_conversation_id_fkey" FOREIGN KEY ("conversation_id") REFERENCES "public"."conversations"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."music_requests"
    ADD CONSTRAINT "music_requests_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."notifications"
    ADD CONSTRAINT "notifications_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."pending_logins"
    ADD CONSTRAINT "pending_logins_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."playlist_tracks"
    ADD CONSTRAINT "playlist_tracks_playlist_id_fkey" FOREIGN KEY ("playlist_id") REFERENCES "public"."playlists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."playlist_tracks"
    ADD CONSTRAINT "playlist_tracks_track_id_fkey" FOREIGN KEY ("track_id") REFERENCES "public"."tracks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."playlists"
    ADD CONSTRAINT "playlists_owner_id_fkey" FOREIGN KEY ("owner_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."prices"
    ADD CONSTRAINT "prices_product_id_fkey" FOREIGN KEY ("product_id") REFERENCES "public"."products"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."product_drafts"
    ADD CONSTRAINT "product_drafts_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."profiles"
    ADD CONSTRAINT "profiles_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."project"
    ADD CONSTRAINT "projects_creatorId_foreign" FOREIGN KEY ("creatorId") REFERENCES "public"."user"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."saved_blends"
    ADD CONSTRAINT "saved_blends_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."songs"
    ADD CONSTRAINT "songs_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_price_id_fkey" FOREIGN KEY ("price_id") REFERENCES "public"."prices"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."subscriptions"
    ADD CONSTRAINT "subscriptions_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."track_artists"
    ADD CONSTRAINT "track_artists_artist_id_fkey" FOREIGN KEY ("artist_id") REFERENCES "public"."artists"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."track_artists"
    ADD CONSTRAINT "track_artists_track_id_fkey" FOREIGN KEY ("track_id") REFERENCES "public"."tracks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."tracks"
    ADD CONSTRAINT "tracks_album_id_fkey" FOREIGN KEY ("album_id") REFERENCES "public"."albums"("id") ON DELETE SET NULL;



ALTER TABLE ONLY "public"."user_settings"
    ADD CONSTRAINT "user_settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "public"."profiles"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."user_spotify_tokens"
    ADD CONSTRAINT "user_spotify_tokens_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."users"
    ADD CONSTRAINT "users_id_fkey" FOREIGN KEY ("id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."verse_music_playlist"
    ADD CONSTRAINT "verse_music_playlist_media_asset_id_fkey" FOREIGN KEY ("media_asset_id") REFERENCES "public"."media_assets"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."voice_consents"
    ADD CONSTRAINT "voice_consents_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "AI agents are viewable by everyone." ON "public"."ai_agents" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "Allow authenticated users to insert spotify recommendations" ON "public"."spotify_recommendations" FOR INSERT WITH CHECK (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow authenticated users to update spotify recommendations" ON "public"."spotify_recommendations" FOR UPDATE USING (("auth"."role"() = 'authenticated'::"text"));



CREATE POLICY "Allow public read access to spotify recommendations" ON "public"."spotify_recommendations" FOR SELECT USING (true);



CREATE POLICY "Anyone can view fragrance blends" ON "public"."fragrance_blends" FOR SELECT USING (true);



CREATE POLICY "Anyone can view fragrance reviews" ON "public"."fragrance_reviews" FOR SELECT USING (true);



CREATE POLICY "Authenticated users can insert fragrance blends" ON "public"."fragrance_blends" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can insert fragrance reviews" ON "public"."fragrance_reviews" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Authenticated users can view all documents." ON "public"."documents" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Authenticated users can view all ollama documents." ON "public"."ollama_documents" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "Only admins can manage AI agents." ON "public"."ai_agents" TO "authenticated" USING (( SELECT "profiles"."is_admin"
   FROM "public"."profiles"
  WHERE ("profiles"."id" = "auth"."uid"())));



CREATE POLICY "Only admins can manage documents." ON "public"."documents" TO "authenticated" USING (( SELECT "profiles"."is_admin"
   FROM "public"."profiles"
  WHERE ("profiles"."id" = "auth"."uid"())));



CREATE POLICY "Only admins can manage ollama documents." ON "public"."ollama_documents" TO "authenticated" USING (( SELECT "profiles"."is_admin"
   FROM "public"."profiles"
  WHERE ("profiles"."id" = "auth"."uid"())));



CREATE POLICY "Only admins can view analytics." ON "public"."analytics" FOR SELECT TO "authenticated" USING (( SELECT "profiles"."is_admin"
   FROM "public"."profiles"
  WHERE ("profiles"."id" = "auth"."uid"())));



CREATE POLICY "Public documents are viewable by everyone." ON "public"."documents" FOR SELECT TO "authenticated", "anon" USING (("is_public" = true));



CREATE POLICY "Public ollama documents are viewable by everyone." ON "public"."ollama_documents" FOR SELECT TO "authenticated", "anon" USING (("is_public" = true));



CREATE POLICY "Public profiles are viewable by everyone." ON "public"."profiles" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "Service role can do all" ON "public"."profiles" USING ((("auth"."jwt"() ->> 'role'::"text") = 'service_role'::"text"));



CREATE POLICY "Service role only on code_verifiers" ON "public"."customer_account_code_verifiers" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "Service role only on tokens" ON "public"."customer_account_tokens" USING (("auth"."role"() = 'service_role'::"text"));



CREATE POLICY "System can create notifications." ON "public"."notifications" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "System can insert analytics." ON "public"."analytics" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "Users can create their own conversations." ON "public"."conversations" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can delete messages in their conversations." ON "public"."messages" FOR DELETE TO "authenticated" USING (("conversation_id" IN ( SELECT "conversations"."id"
   FROM "public"."conversations"
  WHERE ("conversations"."user_id" = "auth"."uid"()))));



CREATE POLICY "Users can delete their own conversations." ON "public"."conversations" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can delete their own notifications." ON "public"."notifications" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can delete their own settings." ON "public"."user_settings" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can insert messages in their conversations." ON "public"."messages" FOR INSERT TO "authenticated" WITH CHECK (("conversation_id" IN ( SELECT "conversations"."id"
   FROM "public"."conversations"
  WHERE ("conversations"."user_id" = "auth"."uid"()))));



CREATE POLICY "Users can insert their own settings." ON "public"."user_settings" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update their own conversations." ON "public"."conversations" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update their own messages." ON "public"."messages" FOR UPDATE TO "authenticated" USING ((("sender_type" = 'user'::"text") AND ("sender_id" = "auth"."uid"()) AND ("conversation_id" IN ( SELECT "conversations"."id"
   FROM "public"."conversations"
  WHERE ("conversations"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can update their own notifications." ON "public"."notifications" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can update their own settings." ON "public"."user_settings" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view messages in their conversations." ON "public"."messages" FOR SELECT TO "authenticated" USING (("conversation_id" IN ( SELECT "conversations"."id"
   FROM "public"."conversations"
  WHERE ("conversations"."user_id" = "auth"."uid"()))));



CREATE POLICY "Users can view their own conversations." ON "public"."conversations" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own notifications." ON "public"."notifications" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users can view their own settings." ON "public"."user_settings" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "Users cannot delete profiles." ON "public"."profiles" FOR DELETE TO "authenticated" USING (false);



CREATE POLICY "admin_all_agent_profiles" ON "public"."agent_profiles" TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND (("profiles"."role" = 'admin'::"text") OR ("profiles"."is_admin" = true))))));



ALTER TABLE "public"."agent_profiles" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ai_agents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."albums" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "albums_insert_authenticated" ON "public"."albums" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "albums_select_anon" ON "public"."albums" FOR SELECT TO "anon" USING (true);



CREATE POLICY "albums_select_authenticated" ON "public"."albums" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."analytics" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."artists" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "artists_insert_authenticated" ON "public"."artists" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "artists_select_anon" ON "public"."artists" FOR SELECT TO "anon" USING (true);



CREATE POLICY "artists_select_authenticated" ON "public"."artists" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."audio_transcripts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "audio_transcripts_delete_own" ON "public"."audio_transcripts" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "audio_transcripts_insert_own" ON "public"."audio_transcripts" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "audio_transcripts_select_own" ON "public"."audio_transcripts" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "audio_transcripts_update_own" ON "public"."audio_transcripts" FOR UPDATE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "blends_delete_own" ON "public"."saved_blends" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "blends_insert_own" ON "public"."saved_blends" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "blends_select_own" ON "public"."saved_blends" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "blends_update_own" ON "public"."saved_blends" FOR UPDATE USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."chat_messages" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "chat_messages_delete_own_session" ON "public"."chat_messages" FOR DELETE TO "authenticated" USING (("session_id" IN ( SELECT "chat_sessions"."id"
   FROM "public"."chat_sessions"
  WHERE ("chat_sessions"."user_id" = "auth"."uid"()))));



CREATE POLICY "chat_messages_insert_own_session" ON "public"."chat_messages" FOR INSERT TO "authenticated" WITH CHECK (("session_id" IN ( SELECT "chat_sessions"."id"
   FROM "public"."chat_sessions"
  WHERE ("chat_sessions"."user_id" = "auth"."uid"()))));



CREATE POLICY "chat_messages_select_own_session" ON "public"."chat_messages" FOR SELECT TO "authenticated" USING (("session_id" IN ( SELECT "chat_sessions"."id"
   FROM "public"."chat_sessions"
  WHERE ("chat_sessions"."user_id" = "auth"."uid"()))));



CREATE POLICY "chat_messages_update_own_session" ON "public"."chat_messages" FOR UPDATE TO "authenticated" USING (("session_id" IN ( SELECT "chat_sessions"."id"
   FROM "public"."chat_sessions"
  WHERE ("chat_sessions"."user_id" = "auth"."uid"())))) WITH CHECK (("session_id" IN ( SELECT "chat_sessions"."id"
   FROM "public"."chat_sessions"
  WHERE ("chat_sessions"."user_id" = "auth"."uid"()))));



ALTER TABLE "public"."chat_sessions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "chat_sessions_delete_own" ON "public"."chat_sessions" FOR DELETE TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "chat_sessions_insert_own" ON "public"."chat_sessions" FOR INSERT TO "authenticated" WITH CHECK (("user_id" = "auth"."uid"()));



CREATE POLICY "chat_sessions_select_own" ON "public"."chat_sessions" FOR SELECT TO "authenticated" USING (("user_id" = "auth"."uid"()));



CREATE POLICY "chat_sessions_update_own" ON "public"."chat_sessions" FOR UPDATE TO "authenticated" USING (("user_id" = "auth"."uid"())) WITH CHECK (("user_id" = "auth"."uid"()));



ALTER TABLE "public"."conversations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."custom_voices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "custom_voices_delete_own" ON "public"."custom_voices" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "custom_voices_insert_own" ON "public"."custom_voices" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "custom_voices_select_own" ON "public"."custom_voices" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "custom_voices_update_own" ON "public"."custom_voices" FOR UPDATE USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."customer_account_code_verifiers" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."customer_account_tokens" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."customers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "customers_insert_authenticated" ON "public"."customers" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "customers_select_authenticated" ON "public"."customers" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "id"));



CREATE POLICY "customers_update_authenticated" ON "public"."customers" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "id")) WITH CHECK (("auth"."uid"() = "id"));



ALTER TABLE "public"."documents" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "drafts_delete_own" ON "public"."product_drafts" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "drafts_insert_own" ON "public"."product_drafts" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "drafts_select_own" ON "public"."product_drafts" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "drafts_update_own" ON "public"."product_drafts" FOR UPDATE USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."formula_categories" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "formula_categories_select_all" ON "public"."formula_categories" FOR SELECT USING (true);



ALTER TABLE "public"."formula_ingredients" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "formula_ingredients_select_all" ON "public"."formula_ingredients" FOR SELECT USING (true);



ALTER TABLE "public"."formula_phases" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "formula_phases_select_all" ON "public"."formula_phases" FOR SELECT USING (true);



ALTER TABLE "public"."formulas" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "formulas_select_all" ON "public"."formulas" FOR SELECT USING (true);



ALTER TABLE "public"."fragrance_blends" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."fragrance_notes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "fragrance_notes_select_authenticated" ON "public"."fragrance_notes" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



ALTER TABLE "public"."fragrance_oils" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "fragrance_oils_select_authenticated" ON "public"."fragrance_oils" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



ALTER TABLE "public"."fragrance_reviews" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."funnel_answers" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "funnel_answers_delete_own_run" ON "public"."funnel_answers" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."funnel_runs"
  WHERE (("funnel_runs"."id" = "funnel_answers"."run_id") AND ("funnel_runs"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "funnel_answers_insert_own_run" ON "public"."funnel_answers" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."funnel_runs"
  WHERE (("funnel_runs"."id" = "funnel_answers"."run_id") AND ("funnel_runs"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "funnel_answers_select_own_run" ON "public"."funnel_answers" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."funnel_runs"
  WHERE (("funnel_runs"."id" = "funnel_answers"."run_id") AND ("funnel_runs"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



ALTER TABLE "public"."funnel_definitions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "funnel_definitions_delete_admin" ON "public"."funnel_definitions" FOR DELETE TO "authenticated" USING ("public"."is_admin"());



CREATE POLICY "funnel_definitions_insert_admin" ON "public"."funnel_definitions" FOR INSERT TO "authenticated" WITH CHECK ("public"."is_admin"());



CREATE POLICY "funnel_definitions_select_authenticated" ON "public"."funnel_definitions" FOR SELECT TO "authenticated" USING ((("status" = 'active'::"text") OR "public"."is_admin"()));



CREATE POLICY "funnel_definitions_update_admin" ON "public"."funnel_definitions" FOR UPDATE TO "authenticated" USING ("public"."is_admin"());



ALTER TABLE "public"."funnel_events" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "funnel_events_insert_own_run" ON "public"."funnel_events" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."funnel_runs"
  WHERE (("funnel_runs"."id" = "funnel_events"."run_id") AND ("funnel_runs"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "funnel_events_select_own_run" ON "public"."funnel_events" FOR SELECT TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."funnel_runs"
  WHERE (("funnel_runs"."id" = "funnel_events"."run_id") AND ("funnel_runs"."user_id" = ( SELECT "auth"."uid"() AS "uid"))))));



ALTER TABLE "public"."funnel_runs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "funnel_runs_insert_own" ON "public"."funnel_runs" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "funnel_runs_select_own" ON "public"."funnel_runs" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "funnel_runs_update_own" ON "public"."funnel_runs" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



ALTER TABLE "public"."liked_navidrome_tracks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "liked_navidrome_tracks_delete_authenticated" ON "public"."liked_navidrome_tracks" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "liked_navidrome_tracks_insert_authenticated" ON "public"."liked_navidrome_tracks" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "liked_navidrome_tracks_select_authenticated" ON "public"."liked_navidrome_tracks" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."liked_songs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "liked_songs_delete_authenticated" ON "public"."liked_songs" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "liked_songs_insert_authenticated" ON "public"."liked_songs" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "liked_songs_select_authenticated" ON "public"."liked_songs" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."likes" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "likes_delete_authenticated" ON "public"."likes" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "likes_insert_authenticated" ON "public"."likes" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "likes_select_authenticated" ON "public"."likes" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



ALTER TABLE "public"."listening_history" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "listening_history_insert_authenticated" ON "public"."listening_history" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



CREATE POLICY "listening_history_select_authenticated" ON "public"."listening_history" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "user_id"));



ALTER TABLE "public"."media_assets" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "media_delete_own" ON "public"."media_assets" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "media_insert_own" ON "public"."media_assets" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "media_select_own" ON "public"."media_assets" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "media_update_own" ON "public"."media_assets" FOR UPDATE USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."messages" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."music_requests" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "music_requests_insert_authenticated" ON "public"."music_requests" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "music_requests_select_authenticated" ON "public"."music_requests" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "music_requests_update_authenticated" ON "public"."music_requests" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."notifications" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."ollama_documents" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."pending_logins" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."playlist_tracks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "playlist_tracks_delete_authenticated" ON "public"."playlist_tracks" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."playlists" "p"
  WHERE (("p"."id" = "playlist_tracks"."playlist_id") AND ("p"."owner_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "playlist_tracks_insert_authenticated" ON "public"."playlist_tracks" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."playlists" "p"
  WHERE (("p"."id" = "playlist_tracks"."playlist_id") AND ("p"."owner_id" = ( SELECT "auth"."uid"() AS "uid"))))));



CREATE POLICY "playlist_tracks_select_anon" ON "public"."playlist_tracks" FOR SELECT TO "anon" USING (true);



CREATE POLICY "playlist_tracks_select_authenticated" ON "public"."playlist_tracks" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "playlist_tracks_update_authenticated" ON "public"."playlist_tracks" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."playlists" "p"
  WHERE (("p"."id" = "playlist_tracks"."playlist_id") AND ("p"."owner_id" = ( SELECT "auth"."uid"() AS "uid")))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."playlists" "p"
  WHERE (("p"."id" = "playlist_tracks"."playlist_id") AND ("p"."owner_id" = ( SELECT "auth"."uid"() AS "uid"))))));



ALTER TABLE "public"."playlists" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "playlists_delete_authenticated" ON "public"."playlists" FOR DELETE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "owner_id"));



CREATE POLICY "playlists_insert_authenticated" ON "public"."playlists" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "owner_id"));



CREATE POLICY "playlists_select_anon" ON "public"."playlists" FOR SELECT TO "anon" USING (true);



CREATE POLICY "playlists_select_authenticated" ON "public"."playlists" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "playlists_update_authenticated" ON "public"."playlists" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "owner_id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "owner_id"));



ALTER TABLE "public"."prices" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "prices_select_anon" ON "public"."prices" FOR SELECT TO "anon" USING (true);



CREATE POLICY "prices_select_authenticated" ON "public"."prices" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."product_drafts" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."products" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "products_select_anon" ON "public"."products" FOR SELECT TO "anon" USING (true);



CREATE POLICY "products_select_authenticated" ON "public"."products" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."profiles" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "profiles_admin_select_all" ON "public"."profiles" FOR SELECT TO "authenticated" USING ("public"."is_admin"());



CREATE POLICY "profiles_admin_update_any" ON "public"."profiles" FOR UPDATE TO "authenticated" USING ("public"."is_admin"()) WITH CHECK (true);



CREATE POLICY "profiles_insert_own" ON "public"."profiles" FOR INSERT TO "authenticated" WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "id"));



CREATE POLICY "profiles_select_own" ON "public"."profiles" FOR SELECT TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "id"));



CREATE POLICY "profiles_select_public" ON "public"."profiles" FOR SELECT TO "authenticated", "anon" USING (("handle" IS NOT NULL));



CREATE POLICY "profiles_update_own" ON "public"."profiles" FOR UPDATE TO "authenticated" USING ((( SELECT "auth"."uid"() AS "uid") = "id")) WITH CHECK ((( SELECT "auth"."uid"() AS "uid") = "id"));



CREATE POLICY "public_read_active_agent_profiles" ON "public"."agent_profiles" FOR SELECT TO "authenticated", "anon" USING (("is_active" = true));



ALTER TABLE "public"."saved_blends" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."songs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "songs_delete_authenticated" ON "public"."songs" FOR DELETE TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "songs_insert_authenticated" ON "public"."songs" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "songs_select_anon" ON "public"."songs" FOR SELECT TO "anon" USING (true);



CREATE POLICY "songs_select_authenticated" ON "public"."songs" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "songs_update_authenticated" ON "public"."songs" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."spotify_recommendations" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."subscriptions" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "subscriptions_insert_authenticated" ON "public"."subscriptions" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "subscriptions_select_authenticated" ON "public"."subscriptions" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "subscriptions_update_authenticated" ON "public"."subscriptions" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."sync_logs" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "sync_logs_select_authenticated" ON "public"."sync_logs" FOR SELECT USING (("auth"."role"() = 'authenticated'::"text"));



ALTER TABLE "public"."track_artists" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "track_artists_insert_authenticated" ON "public"."track_artists" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "track_artists_select_anon" ON "public"."track_artists" FOR SELECT TO "anon" USING (true);



CREATE POLICY "track_artists_select_authenticated" ON "public"."track_artists" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."tracks" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "tracks_insert_authenticated" ON "public"."tracks" FOR INSERT TO "authenticated" WITH CHECK (true);



CREATE POLICY "tracks_select_anon" ON "public"."tracks" FOR SELECT TO "anon" USING (true);



CREATE POLICY "tracks_select_authenticated" ON "public"."tracks" FOR SELECT TO "authenticated" USING (true);



ALTER TABLE "public"."user_settings" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."user_spotify_tokens" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "user_spotify_tokens_insert_authenticated" ON "public"."user_spotify_tokens" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "user_spotify_tokens_select_authenticated" ON "public"."user_spotify_tokens" FOR SELECT TO "authenticated" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "user_spotify_tokens_update_authenticated" ON "public"."user_spotify_tokens" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "user_id")) WITH CHECK (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."users" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "users_insert_authenticated" ON "public"."users" FOR INSERT TO "authenticated" WITH CHECK (("auth"."uid"() = "id"));



CREATE POLICY "users_select_anon" ON "public"."users" FOR SELECT TO "anon" USING (true);



CREATE POLICY "users_select_authenticated" ON "public"."users" FOR SELECT TO "authenticated" USING (true);



CREATE POLICY "users_update_authenticated" ON "public"."users" FOR UPDATE TO "authenticated" USING (("auth"."uid"() = "id")) WITH CHECK (("auth"."uid"() = "id"));



ALTER TABLE "public"."verse_blog_posts" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "verse_blog_posts_select_published" ON "public"."verse_blog_posts" FOR SELECT USING (("status" = 'published'::"text"));



ALTER TABLE "public"."verse_music_playlist" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "verse_music_playlist_delete_admin" ON "public"."verse_music_playlist" FOR DELETE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND (("profiles"."role" = 'admin'::"text") OR ("profiles"."is_admin" = true))))));



CREATE POLICY "verse_music_playlist_insert_admin" ON "public"."verse_music_playlist" FOR INSERT TO "authenticated" WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND (("profiles"."role" = 'admin'::"text") OR ("profiles"."is_admin" = true))))));



CREATE POLICY "verse_music_playlist_select_public" ON "public"."verse_music_playlist" FOR SELECT TO "authenticated", "anon" USING (true);



CREATE POLICY "verse_music_playlist_update_admin" ON "public"."verse_music_playlist" FOR UPDATE TO "authenticated" USING ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND (("profiles"."role" = 'admin'::"text") OR ("profiles"."is_admin" = true)))))) WITH CHECK ((EXISTS ( SELECT 1
   FROM "public"."profiles"
  WHERE (("profiles"."id" = "auth"."uid"()) AND (("profiles"."role" = 'admin'::"text") OR ("profiles"."is_admin" = true))))));



ALTER TABLE "public"."voice_consents" ENABLE ROW LEVEL SECURITY;


CREATE POLICY "voice_consents_delete_own" ON "public"."voice_consents" FOR DELETE USING (("auth"."uid"() = "user_id"));



CREATE POLICY "voice_consents_insert_own" ON "public"."voice_consents" FOR INSERT WITH CHECK (("auth"."uid"() = "user_id"));



CREATE POLICY "voice_consents_select_own" ON "public"."voice_consents" FOR SELECT USING (("auth"."uid"() = "user_id"));



CREATE POLICY "voice_consents_update_own" ON "public"."voice_consents" FOR UPDATE USING (("auth"."uid"() = "user_id"));



REVOKE USAGE ON SCHEMA "public" FROM PUBLIC;
GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



GRANT ALL ON FUNCTION "public"."check_current_bucket_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."check_current_bucket_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."check_current_bucket_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."create_notification"("user_id" "uuid", "title" "text", "message" "text", "type" "text", "action_url" "text", "metadata" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."create_notification"("user_id" "uuid", "title" "text", "message" "text", "type" "text", "action_url" "text", "metadata" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_notification"("user_id" "uuid", "title" "text", "message" "text", "type" "text", "action_url" "text", "metadata" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."create_user_bucket"() TO "anon";
GRANT ALL ON FUNCTION "public"."create_user_bucket"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."create_user_bucket"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_new_user_settings"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_new_user_settings"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_new_user_settings"() TO "service_role";



GRANT ALL ON FUNCTION "public"."handle_profile_updated"() TO "anon";
GRANT ALL ON FUNCTION "public"."handle_profile_updated"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."handle_profile_updated"() TO "service_role";



GRANT ALL ON FUNCTION "public"."hybrid_search"("query_text" "text", "query_embedding" "extensions"."vector", "match_count" integer) TO "anon";
GRANT ALL ON FUNCTION "public"."hybrid_search"("query_text" "text", "query_embedding" "extensions"."vector", "match_count" integer) TO "authenticated";
GRANT ALL ON FUNCTION "public"."hybrid_search"("query_text" "text", "query_embedding" "extensions"."vector", "match_count" integer) TO "service_role";



GRANT ALL ON FUNCTION "public"."increment_workflow_version"() TO "anon";
GRANT ALL ON FUNCTION "public"."increment_workflow_version"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."increment_workflow_version"() TO "service_role";



GRANT ALL ON FUNCTION "public"."is_admin"() TO "anon";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."is_admin"() TO "service_role";



GRANT ALL ON FUNCTION "public"."log_user_action"("user_id" "uuid", "action" "text", "details" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."log_user_action"("user_id" "uuid", "action" "text", "details" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."log_user_action"("user_id" "uuid", "action" "text", "details" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."match_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."match_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."match_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."match_ollama_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") TO "anon";
GRANT ALL ON FUNCTION "public"."match_ollama_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") TO "authenticated";
GRANT ALL ON FUNCTION "public"."match_ollama_documents"("query_embedding" "extensions"."vector", "match_count" integer, "filter" "jsonb") TO "service_role";



GRANT ALL ON FUNCTION "public"."prevent_non_admin_role_update"() TO "anon";
GRANT ALL ON FUNCTION "public"."prevent_non_admin_role_update"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."prevent_non_admin_role_update"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_agent_profiles_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_agent_profiles_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_agent_profiles_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_profiles_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_profiles_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_profiles_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."set_updated_at_metadata"() TO "anon";
GRANT ALL ON FUNCTION "public"."set_updated_at_metadata"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."set_updated_at_metadata"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_is_admin_from_role"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_is_admin_from_role"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_is_admin_from_role"() TO "service_role";



GRANT ALL ON FUNCTION "public"."sync_profile_from_auth_user"() TO "anon";
GRANT ALL ON FUNCTION "public"."sync_profile_from_auth_user"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."sync_profile_from_auth_user"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_spotify_recommendations_updated_at"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_spotify_recommendations_updated_at"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_spotify_recommendations_updated_at"() TO "service_role";



GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "anon";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."update_updated_at_column"() TO "service_role";



GRANT ALL ON FUNCTION "public"."uuid_generate_v4"() TO "anon";
GRANT ALL ON FUNCTION "public"."uuid_generate_v4"() TO "authenticated";
GRANT ALL ON FUNCTION "public"."uuid_generate_v4"() TO "service_role";



GRANT ALL ON TABLE "public"."agent_profiles" TO "anon";
GRANT ALL ON TABLE "public"."agent_profiles" TO "authenticated";
GRANT ALL ON TABLE "public"."agent_profiles" TO "service_role";



GRANT ALL ON TABLE "public"."ai_agents" TO "anon";
GRANT ALL ON TABLE "public"."ai_agents" TO "authenticated";
GRANT ALL ON TABLE "public"."ai_agents" TO "service_role";



GRANT ALL ON TABLE "public"."albums" TO "anon";
GRANT ALL ON TABLE "public"."albums" TO "authenticated";
GRANT ALL ON TABLE "public"."albums" TO "service_role";



GRANT ALL ON TABLE "public"."analytics" TO "anon";
GRANT ALL ON TABLE "public"."analytics" TO "authenticated";
GRANT ALL ON TABLE "public"."analytics" TO "service_role";



GRANT ALL ON TABLE "public"."annotation_tag_entity" TO "anon";
GRANT ALL ON TABLE "public"."annotation_tag_entity" TO "authenticated";
GRANT ALL ON TABLE "public"."annotation_tag_entity" TO "service_role";



GRANT ALL ON TABLE "public"."apikey" TO "anon";
GRANT ALL ON TABLE "public"."apikey" TO "authenticated";
GRANT ALL ON TABLE "public"."apikey" TO "service_role";



GRANT ALL ON TABLE "public"."artists" TO "anon";
GRANT ALL ON TABLE "public"."artists" TO "authenticated";
GRANT ALL ON TABLE "public"."artists" TO "service_role";



GRANT ALL ON TABLE "public"."assistant" TO "anon";
GRANT ALL ON TABLE "public"."assistant" TO "authenticated";
GRANT ALL ON TABLE "public"."assistant" TO "service_role";



GRANT ALL ON TABLE "public"."audio_transcripts" TO "anon";
GRANT ALL ON TABLE "public"."audio_transcripts" TO "authenticated";
GRANT ALL ON TABLE "public"."audio_transcripts" TO "service_role";



GRANT ALL ON TABLE "public"."auth_identity" TO "anon";
GRANT ALL ON TABLE "public"."auth_identity" TO "authenticated";
GRANT ALL ON TABLE "public"."auth_identity" TO "service_role";



GRANT ALL ON TABLE "public"."auth_provider_sync_history" TO "anon";
GRANT ALL ON TABLE "public"."auth_provider_sync_history" TO "authenticated";
GRANT ALL ON TABLE "public"."auth_provider_sync_history" TO "service_role";



GRANT ALL ON SEQUENCE "public"."auth_provider_sync_history_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."auth_provider_sync_history_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."auth_provider_sync_history_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."binary_data" TO "anon";
GRANT ALL ON TABLE "public"."binary_data" TO "authenticated";
GRANT ALL ON TABLE "public"."binary_data" TO "service_role";



GRANT ALL ON TABLE "public"."chat_flow" TO "anon";
GRANT ALL ON TABLE "public"."chat_flow" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_flow" TO "service_role";



GRANT ALL ON TABLE "public"."chat_hub_agents" TO "anon";
GRANT ALL ON TABLE "public"."chat_hub_agents" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_hub_agents" TO "service_role";



GRANT ALL ON TABLE "public"."chat_hub_messages" TO "anon";
GRANT ALL ON TABLE "public"."chat_hub_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_hub_messages" TO "service_role";



GRANT ALL ON TABLE "public"."chat_hub_sessions" TO "anon";
GRANT ALL ON TABLE "public"."chat_hub_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_hub_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."chat_message" TO "anon";
GRANT ALL ON TABLE "public"."chat_message" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_message" TO "service_role";



GRANT ALL ON TABLE "public"."chat_message_feedback" TO "anon";
GRANT ALL ON TABLE "public"."chat_message_feedback" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_message_feedback" TO "service_role";



GRANT ALL ON TABLE "public"."chat_messages" TO "anon";
GRANT ALL ON TABLE "public"."chat_messages" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_messages" TO "service_role";



GRANT ALL ON TABLE "public"."chat_sessions" TO "anon";
GRANT ALL ON TABLE "public"."chat_sessions" TO "authenticated";
GRANT ALL ON TABLE "public"."chat_sessions" TO "service_role";



GRANT ALL ON TABLE "public"."conversations" TO "anon";
GRANT ALL ON TABLE "public"."conversations" TO "authenticated";
GRANT ALL ON TABLE "public"."conversations" TO "service_role";



GRANT ALL ON TABLE "public"."credential" TO "anon";
GRANT ALL ON TABLE "public"."credential" TO "authenticated";
GRANT ALL ON TABLE "public"."credential" TO "service_role";



GRANT ALL ON TABLE "public"."credentials_entity" TO "anon";
GRANT ALL ON TABLE "public"."credentials_entity" TO "authenticated";
GRANT ALL ON TABLE "public"."credentials_entity" TO "service_role";



GRANT ALL ON TABLE "public"."custom_template" TO "anon";
GRANT ALL ON TABLE "public"."custom_template" TO "authenticated";
GRANT ALL ON TABLE "public"."custom_template" TO "service_role";



GRANT ALL ON TABLE "public"."custom_voices" TO "anon";
GRANT ALL ON TABLE "public"."custom_voices" TO "authenticated";
GRANT ALL ON TABLE "public"."custom_voices" TO "service_role";



GRANT ALL ON TABLE "public"."customer_account_code_verifiers" TO "anon";
GRANT ALL ON TABLE "public"."customer_account_code_verifiers" TO "authenticated";
GRANT ALL ON TABLE "public"."customer_account_code_verifiers" TO "service_role";



GRANT ALL ON TABLE "public"."customer_account_tokens" TO "anon";
GRANT ALL ON TABLE "public"."customer_account_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."customer_account_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."customers" TO "anon";
GRANT ALL ON TABLE "public"."customers" TO "authenticated";
GRANT ALL ON TABLE "public"."customers" TO "service_role";



GRANT ALL ON TABLE "public"."data_table" TO "anon";
GRANT ALL ON TABLE "public"."data_table" TO "authenticated";
GRANT ALL ON TABLE "public"."data_table" TO "service_role";



GRANT ALL ON TABLE "public"."data_table_column" TO "anon";
GRANT ALL ON TABLE "public"."data_table_column" TO "authenticated";
GRANT ALL ON TABLE "public"."data_table_column" TO "service_role";



GRANT ALL ON TABLE "public"."document_store" TO "anon";
GRANT ALL ON TABLE "public"."document_store" TO "authenticated";
GRANT ALL ON TABLE "public"."document_store" TO "service_role";



GRANT ALL ON TABLE "public"."document_store_file_chunk" TO "anon";
GRANT ALL ON TABLE "public"."document_store_file_chunk" TO "authenticated";
GRANT ALL ON TABLE "public"."document_store_file_chunk" TO "service_role";



GRANT ALL ON TABLE "public"."documents" TO "anon";
GRANT ALL ON TABLE "public"."documents" TO "authenticated";
GRANT ALL ON TABLE "public"."documents" TO "service_role";



GRANT ALL ON TABLE "public"."dynamic_credential_entry" TO "anon";
GRANT ALL ON TABLE "public"."dynamic_credential_entry" TO "authenticated";
GRANT ALL ON TABLE "public"."dynamic_credential_entry" TO "service_role";



GRANT ALL ON TABLE "public"."dynamic_credential_resolver" TO "anon";
GRANT ALL ON TABLE "public"."dynamic_credential_resolver" TO "authenticated";
GRANT ALL ON TABLE "public"."dynamic_credential_resolver" TO "service_role";



GRANT ALL ON TABLE "public"."event_destinations" TO "anon";
GRANT ALL ON TABLE "public"."event_destinations" TO "authenticated";
GRANT ALL ON TABLE "public"."event_destinations" TO "service_role";



GRANT ALL ON TABLE "public"."execution_annotation_tags" TO "anon";
GRANT ALL ON TABLE "public"."execution_annotation_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."execution_annotation_tags" TO "service_role";



GRANT ALL ON TABLE "public"."execution_annotations" TO "anon";
GRANT ALL ON TABLE "public"."execution_annotations" TO "authenticated";
GRANT ALL ON TABLE "public"."execution_annotations" TO "service_role";



GRANT ALL ON SEQUENCE "public"."execution_annotations_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."execution_annotations_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."execution_annotations_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."execution_data" TO "anon";
GRANT ALL ON TABLE "public"."execution_data" TO "authenticated";
GRANT ALL ON TABLE "public"."execution_data" TO "service_role";



GRANT ALL ON TABLE "public"."execution_entity" TO "anon";
GRANT ALL ON TABLE "public"."execution_entity" TO "authenticated";
GRANT ALL ON TABLE "public"."execution_entity" TO "service_role";



GRANT ALL ON SEQUENCE "public"."execution_entity_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."execution_entity_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."execution_entity_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."execution_metadata" TO "anon";
GRANT ALL ON TABLE "public"."execution_metadata" TO "authenticated";
GRANT ALL ON TABLE "public"."execution_metadata" TO "service_role";



GRANT ALL ON SEQUENCE "public"."execution_metadata_temp_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."execution_metadata_temp_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."execution_metadata_temp_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."folder" TO "anon";
GRANT ALL ON TABLE "public"."folder" TO "authenticated";
GRANT ALL ON TABLE "public"."folder" TO "service_role";



GRANT ALL ON TABLE "public"."folder_tag" TO "anon";
GRANT ALL ON TABLE "public"."folder_tag" TO "authenticated";
GRANT ALL ON TABLE "public"."folder_tag" TO "service_role";



GRANT ALL ON TABLE "public"."formula_categories" TO "anon";
GRANT ALL ON TABLE "public"."formula_categories" TO "authenticated";
GRANT ALL ON TABLE "public"."formula_categories" TO "service_role";



GRANT ALL ON TABLE "public"."formula_ingredients" TO "anon";
GRANT ALL ON TABLE "public"."formula_ingredients" TO "authenticated";
GRANT ALL ON TABLE "public"."formula_ingredients" TO "service_role";



GRANT ALL ON TABLE "public"."formula_phases" TO "anon";
GRANT ALL ON TABLE "public"."formula_phases" TO "authenticated";
GRANT ALL ON TABLE "public"."formula_phases" TO "service_role";



GRANT ALL ON TABLE "public"."formulas" TO "anon";
GRANT ALL ON TABLE "public"."formulas" TO "authenticated";
GRANT ALL ON TABLE "public"."formulas" TO "service_role";



GRANT ALL ON TABLE "public"."fragrance_blends" TO "anon";
GRANT ALL ON TABLE "public"."fragrance_blends" TO "authenticated";
GRANT ALL ON TABLE "public"."fragrance_blends" TO "service_role";



GRANT ALL ON TABLE "public"."fragrance_notes" TO "anon";
GRANT ALL ON TABLE "public"."fragrance_notes" TO "authenticated";
GRANT ALL ON TABLE "public"."fragrance_notes" TO "service_role";



GRANT ALL ON TABLE "public"."fragrance_oils" TO "anon";
GRANT ALL ON TABLE "public"."fragrance_oils" TO "authenticated";
GRANT ALL ON TABLE "public"."fragrance_oils" TO "service_role";



GRANT ALL ON TABLE "public"."fragrance_reviews" TO "anon";
GRANT ALL ON TABLE "public"."fragrance_reviews" TO "authenticated";
GRANT ALL ON TABLE "public"."fragrance_reviews" TO "service_role";



GRANT ALL ON TABLE "public"."funnel_answers" TO "anon";
GRANT ALL ON TABLE "public"."funnel_answers" TO "authenticated";
GRANT ALL ON TABLE "public"."funnel_answers" TO "service_role";



GRANT ALL ON TABLE "public"."funnel_definitions" TO "anon";
GRANT ALL ON TABLE "public"."funnel_definitions" TO "authenticated";
GRANT ALL ON TABLE "public"."funnel_definitions" TO "service_role";



GRANT ALL ON TABLE "public"."funnel_events" TO "anon";
GRANT ALL ON TABLE "public"."funnel_events" TO "authenticated";
GRANT ALL ON TABLE "public"."funnel_events" TO "service_role";



GRANT ALL ON TABLE "public"."funnel_runs" TO "anon";
GRANT ALL ON TABLE "public"."funnel_runs" TO "authenticated";
GRANT ALL ON TABLE "public"."funnel_runs" TO "service_role";



GRANT ALL ON TABLE "public"."insights_by_period" TO "anon";
GRANT ALL ON TABLE "public"."insights_by_period" TO "authenticated";
GRANT ALL ON TABLE "public"."insights_by_period" TO "service_role";



GRANT ALL ON SEQUENCE "public"."insights_by_period_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."insights_by_period_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."insights_by_period_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."insights_metadata" TO "anon";
GRANT ALL ON TABLE "public"."insights_metadata" TO "authenticated";
GRANT ALL ON TABLE "public"."insights_metadata" TO "service_role";



GRANT ALL ON SEQUENCE "public"."insights_metadata_metaId_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."insights_metadata_metaId_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."insights_metadata_metaId_seq" TO "service_role";



GRANT ALL ON TABLE "public"."insights_raw" TO "anon";
GRANT ALL ON TABLE "public"."insights_raw" TO "authenticated";
GRANT ALL ON TABLE "public"."insights_raw" TO "service_role";



GRANT ALL ON SEQUENCE "public"."insights_raw_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."insights_raw_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."insights_raw_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."installed_nodes" TO "anon";
GRANT ALL ON TABLE "public"."installed_nodes" TO "authenticated";
GRANT ALL ON TABLE "public"."installed_nodes" TO "service_role";



GRANT ALL ON TABLE "public"."installed_packages" TO "anon";
GRANT ALL ON TABLE "public"."installed_packages" TO "authenticated";
GRANT ALL ON TABLE "public"."installed_packages" TO "service_role";



GRANT ALL ON TABLE "public"."invalid_auth_token" TO "anon";
GRANT ALL ON TABLE "public"."invalid_auth_token" TO "authenticated";
GRANT ALL ON TABLE "public"."invalid_auth_token" TO "service_role";



GRANT ALL ON TABLE "public"."lead" TO "anon";
GRANT ALL ON TABLE "public"."lead" TO "authenticated";
GRANT ALL ON TABLE "public"."lead" TO "service_role";



GRANT ALL ON TABLE "public"."liked_navidrome_tracks" TO "anon";
GRANT ALL ON TABLE "public"."liked_navidrome_tracks" TO "authenticated";
GRANT ALL ON TABLE "public"."liked_navidrome_tracks" TO "service_role";



GRANT ALL ON TABLE "public"."liked_songs" TO "anon";
GRANT ALL ON TABLE "public"."liked_songs" TO "authenticated";
GRANT ALL ON TABLE "public"."liked_songs" TO "service_role";



GRANT ALL ON TABLE "public"."likes" TO "anon";
GRANT ALL ON TABLE "public"."likes" TO "authenticated";
GRANT ALL ON TABLE "public"."likes" TO "service_role";



GRANT ALL ON TABLE "public"."listening_history" TO "anon";
GRANT ALL ON TABLE "public"."listening_history" TO "authenticated";
GRANT ALL ON TABLE "public"."listening_history" TO "service_role";



GRANT ALL ON TABLE "public"."media_assets" TO "anon";
GRANT ALL ON TABLE "public"."media_assets" TO "authenticated";
GRANT ALL ON TABLE "public"."media_assets" TO "service_role";



GRANT ALL ON TABLE "public"."messages" TO "anon";
GRANT ALL ON TABLE "public"."messages" TO "authenticated";
GRANT ALL ON TABLE "public"."messages" TO "service_role";



GRANT ALL ON TABLE "public"."migrations" TO "anon";
GRANT ALL ON TABLE "public"."migrations" TO "authenticated";
GRANT ALL ON TABLE "public"."migrations" TO "service_role";



GRANT ALL ON SEQUENCE "public"."migrations_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."migrations_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."migrations_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."music_requests" TO "anon";
GRANT ALL ON TABLE "public"."music_requests" TO "authenticated";
GRANT ALL ON TABLE "public"."music_requests" TO "service_role";



GRANT ALL ON TABLE "public"."notifications" TO "anon";
GRANT ALL ON TABLE "public"."notifications" TO "authenticated";
GRANT ALL ON TABLE "public"."notifications" TO "service_role";



GRANT ALL ON TABLE "public"."oauth_access_tokens" TO "anon";
GRANT ALL ON TABLE "public"."oauth_access_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."oauth_access_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."oauth_authorization_codes" TO "anon";
GRANT ALL ON TABLE "public"."oauth_authorization_codes" TO "authenticated";
GRANT ALL ON TABLE "public"."oauth_authorization_codes" TO "service_role";



GRANT ALL ON TABLE "public"."oauth_clients" TO "anon";
GRANT ALL ON TABLE "public"."oauth_clients" TO "authenticated";
GRANT ALL ON TABLE "public"."oauth_clients" TO "service_role";



GRANT ALL ON TABLE "public"."oauth_refresh_tokens" TO "anon";
GRANT ALL ON TABLE "public"."oauth_refresh_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."oauth_refresh_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."oauth_user_consents" TO "anon";
GRANT ALL ON TABLE "public"."oauth_user_consents" TO "authenticated";
GRANT ALL ON TABLE "public"."oauth_user_consents" TO "service_role";



GRANT ALL ON SEQUENCE "public"."oauth_user_consents_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."oauth_user_consents_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."oauth_user_consents_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."ollama_documents" TO "anon";
GRANT ALL ON TABLE "public"."ollama_documents" TO "authenticated";
GRANT ALL ON TABLE "public"."ollama_documents" TO "service_role";



GRANT ALL ON TABLE "public"."pending_logins" TO "anon";
GRANT ALL ON TABLE "public"."pending_logins" TO "authenticated";
GRANT ALL ON TABLE "public"."pending_logins" TO "service_role";



GRANT ALL ON TABLE "public"."playlist_tracks" TO "anon";
GRANT ALL ON TABLE "public"."playlist_tracks" TO "authenticated";
GRANT ALL ON TABLE "public"."playlist_tracks" TO "service_role";



GRANT ALL ON TABLE "public"."playlists" TO "anon";
GRANT ALL ON TABLE "public"."playlists" TO "authenticated";
GRANT ALL ON TABLE "public"."playlists" TO "service_role";



GRANT ALL ON TABLE "public"."prices" TO "anon";
GRANT ALL ON TABLE "public"."prices" TO "authenticated";
GRANT ALL ON TABLE "public"."prices" TO "service_role";



GRANT ALL ON TABLE "public"."processed_data" TO "anon";
GRANT ALL ON TABLE "public"."processed_data" TO "authenticated";
GRANT ALL ON TABLE "public"."processed_data" TO "service_role";



GRANT ALL ON TABLE "public"."product_drafts" TO "anon";
GRANT ALL ON TABLE "public"."product_drafts" TO "authenticated";
GRANT ALL ON TABLE "public"."product_drafts" TO "service_role";



GRANT ALL ON TABLE "public"."products" TO "anon";
GRANT ALL ON TABLE "public"."products" TO "authenticated";
GRANT ALL ON TABLE "public"."products" TO "service_role";



GRANT ALL ON TABLE "public"."profiles" TO "service_role";
GRANT SELECT,INSERT,UPDATE ON TABLE "public"."profiles" TO "anon";
GRANT SELECT,INSERT,UPDATE ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("id") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("id"),INSERT("id") ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("avatar_url") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("avatar_url"),INSERT("avatar_url"),UPDATE("avatar_url") ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("bio") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("bio"),INSERT("bio"),UPDATE("bio") ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("created_at") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("created_at") ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("updated_at") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("updated_at") ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("handle") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("handle"),INSERT("handle"),UPDATE("handle") ON TABLE "public"."profiles" TO "authenticated";



GRANT SELECT("display_name") ON TABLE "public"."profiles" TO "anon";
GRANT SELECT("display_name"),INSERT("display_name"),UPDATE("display_name") ON TABLE "public"."profiles" TO "authenticated";



GRANT ALL ON TABLE "public"."project" TO "anon";
GRANT ALL ON TABLE "public"."project" TO "authenticated";
GRANT ALL ON TABLE "public"."project" TO "service_role";



GRANT ALL ON TABLE "public"."project_relation" TO "anon";
GRANT ALL ON TABLE "public"."project_relation" TO "authenticated";
GRANT ALL ON TABLE "public"."project_relation" TO "service_role";



GRANT ALL ON TABLE "public"."role" TO "anon";
GRANT ALL ON TABLE "public"."role" TO "authenticated";
GRANT ALL ON TABLE "public"."role" TO "service_role";



GRANT ALL ON TABLE "public"."role_scope" TO "anon";
GRANT ALL ON TABLE "public"."role_scope" TO "authenticated";
GRANT ALL ON TABLE "public"."role_scope" TO "service_role";



GRANT ALL ON TABLE "public"."saved_blends" TO "anon";
GRANT ALL ON TABLE "public"."saved_blends" TO "authenticated";
GRANT ALL ON TABLE "public"."saved_blends" TO "service_role";



GRANT ALL ON TABLE "public"."scope" TO "anon";
GRANT ALL ON TABLE "public"."scope" TO "authenticated";
GRANT ALL ON TABLE "public"."scope" TO "service_role";



GRANT ALL ON TABLE "public"."settings" TO "anon";
GRANT ALL ON TABLE "public"."settings" TO "authenticated";
GRANT ALL ON TABLE "public"."settings" TO "service_role";



GRANT ALL ON TABLE "public"."shared_credentials" TO "anon";
GRANT ALL ON TABLE "public"."shared_credentials" TO "authenticated";
GRANT ALL ON TABLE "public"."shared_credentials" TO "service_role";



GRANT ALL ON TABLE "public"."shared_workflow" TO "anon";
GRANT ALL ON TABLE "public"."shared_workflow" TO "authenticated";
GRANT ALL ON TABLE "public"."shared_workflow" TO "service_role";



GRANT ALL ON TABLE "public"."songs" TO "anon";
GRANT ALL ON TABLE "public"."songs" TO "authenticated";
GRANT ALL ON TABLE "public"."songs" TO "service_role";



GRANT ALL ON SEQUENCE "public"."songs_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."songs_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."songs_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."spotify_recommendations" TO "anon";
GRANT ALL ON TABLE "public"."spotify_recommendations" TO "authenticated";
GRANT ALL ON TABLE "public"."spotify_recommendations" TO "service_role";



GRANT ALL ON TABLE "public"."subscriptions" TO "anon";
GRANT ALL ON TABLE "public"."subscriptions" TO "authenticated";
GRANT ALL ON TABLE "public"."subscriptions" TO "service_role";



GRANT ALL ON TABLE "public"."sync_logs" TO "anon";
GRANT ALL ON TABLE "public"."sync_logs" TO "authenticated";
GRANT ALL ON TABLE "public"."sync_logs" TO "service_role";



GRANT ALL ON TABLE "public"."tag_entity" TO "anon";
GRANT ALL ON TABLE "public"."tag_entity" TO "authenticated";
GRANT ALL ON TABLE "public"."tag_entity" TO "service_role";



GRANT ALL ON TABLE "public"."test_case_execution" TO "anon";
GRANT ALL ON TABLE "public"."test_case_execution" TO "authenticated";
GRANT ALL ON TABLE "public"."test_case_execution" TO "service_role";



GRANT ALL ON TABLE "public"."test_run" TO "anon";
GRANT ALL ON TABLE "public"."test_run" TO "authenticated";
GRANT ALL ON TABLE "public"."test_run" TO "service_role";



GRANT ALL ON TABLE "public"."tool" TO "anon";
GRANT ALL ON TABLE "public"."tool" TO "authenticated";
GRANT ALL ON TABLE "public"."tool" TO "service_role";



GRANT ALL ON TABLE "public"."track_artists" TO "anon";
GRANT ALL ON TABLE "public"."track_artists" TO "authenticated";
GRANT ALL ON TABLE "public"."track_artists" TO "service_role";



GRANT ALL ON TABLE "public"."tracks" TO "anon";
GRANT ALL ON TABLE "public"."tracks" TO "authenticated";
GRANT ALL ON TABLE "public"."tracks" TO "service_role";



GRANT ALL ON TABLE "public"."upsert_history" TO "anon";
GRANT ALL ON TABLE "public"."upsert_history" TO "authenticated";
GRANT ALL ON TABLE "public"."upsert_history" TO "service_role";



GRANT ALL ON TABLE "public"."user" TO "anon";
GRANT ALL ON TABLE "public"."user" TO "authenticated";
GRANT ALL ON TABLE "public"."user" TO "service_role";



GRANT ALL ON TABLE "public"."user_api_keys" TO "anon";
GRANT ALL ON TABLE "public"."user_api_keys" TO "authenticated";
GRANT ALL ON TABLE "public"."user_api_keys" TO "service_role";



GRANT ALL ON TABLE "public"."user_settings" TO "anon";
GRANT ALL ON TABLE "public"."user_settings" TO "authenticated";
GRANT ALL ON TABLE "public"."user_settings" TO "service_role";



GRANT ALL ON TABLE "public"."user_spotify_tokens" TO "anon";
GRANT ALL ON TABLE "public"."user_spotify_tokens" TO "authenticated";
GRANT ALL ON TABLE "public"."user_spotify_tokens" TO "service_role";



GRANT ALL ON TABLE "public"."users" TO "anon";
GRANT ALL ON TABLE "public"."users" TO "authenticated";
GRANT ALL ON TABLE "public"."users" TO "service_role";



GRANT ALL ON TABLE "public"."variable" TO "anon";
GRANT ALL ON TABLE "public"."variable" TO "authenticated";
GRANT ALL ON TABLE "public"."variable" TO "service_role";



GRANT ALL ON TABLE "public"."variables" TO "anon";
GRANT ALL ON TABLE "public"."variables" TO "authenticated";
GRANT ALL ON TABLE "public"."variables" TO "service_role";



GRANT ALL ON TABLE "public"."verse_blog_posts" TO "anon";
GRANT ALL ON TABLE "public"."verse_blog_posts" TO "authenticated";
GRANT ALL ON TABLE "public"."verse_blog_posts" TO "service_role";



GRANT ALL ON TABLE "public"."verse_music_playlist" TO "anon";
GRANT ALL ON TABLE "public"."verse_music_playlist" TO "authenticated";
GRANT ALL ON TABLE "public"."verse_music_playlist" TO "service_role";



GRANT ALL ON TABLE "public"."voice_consents" TO "anon";
GRANT ALL ON TABLE "public"."voice_consents" TO "authenticated";
GRANT ALL ON TABLE "public"."voice_consents" TO "service_role";



GRANT ALL ON TABLE "public"."webhook_entity" TO "anon";
GRANT ALL ON TABLE "public"."webhook_entity" TO "authenticated";
GRANT ALL ON TABLE "public"."webhook_entity" TO "service_role";



GRANT ALL ON TABLE "public"."workflow_dependency" TO "anon";
GRANT ALL ON TABLE "public"."workflow_dependency" TO "authenticated";
GRANT ALL ON TABLE "public"."workflow_dependency" TO "service_role";



GRANT ALL ON SEQUENCE "public"."workflow_dependency_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."workflow_dependency_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."workflow_dependency_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."workflow_entity" TO "anon";
GRANT ALL ON TABLE "public"."workflow_entity" TO "authenticated";
GRANT ALL ON TABLE "public"."workflow_entity" TO "service_role";



GRANT ALL ON TABLE "public"."workflow_history" TO "anon";
GRANT ALL ON TABLE "public"."workflow_history" TO "authenticated";
GRANT ALL ON TABLE "public"."workflow_history" TO "service_role";



GRANT ALL ON TABLE "public"."workflow_publish_history" TO "anon";
GRANT ALL ON TABLE "public"."workflow_publish_history" TO "authenticated";
GRANT ALL ON TABLE "public"."workflow_publish_history" TO "service_role";



GRANT ALL ON SEQUENCE "public"."workflow_publish_history_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."workflow_publish_history_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."workflow_publish_history_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."workflow_statistics" TO "anon";
GRANT ALL ON TABLE "public"."workflow_statistics" TO "authenticated";
GRANT ALL ON TABLE "public"."workflow_statistics" TO "service_role";



GRANT ALL ON SEQUENCE "public"."workflow_statistics_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."workflow_statistics_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."workflow_statistics_id_seq" TO "service_role";



GRANT ALL ON TABLE "public"."workflows_tags" TO "anon";
GRANT ALL ON TABLE "public"."workflows_tags" TO "authenticated";
GRANT ALL ON TABLE "public"."workflows_tags" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






